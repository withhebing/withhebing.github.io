<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Fate/Grand Order Quest]]></title>
    <url>%2FMurmur%2Ffate-grand-order-quest%2F</url>
    <content type="text"><![CDATA[哈哈哈，一年一度的沙雕活动又来啦！]]></content>
      <categories>
        <category>Murmur</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mini Program]]></title>
    <url>%2FProgramming%2Fmini-program%2F</url>
    <content type="text"><![CDATA[微信小程序的项目结构： 123456789101112131415project|-- pages| |-- index| | |-- index.json index 页面配置| | |-- index.js index 页面逻辑| | |-- index.wxml index 页面结构| | |-- index.wxss index 页面样式表| |-- log| |-- log.json log 页面配置| |-- log.wxml log 页面逻辑| |-- log.js log 页面结构| |-- log.wxss log 页面样式表|-- app.js 小程序逻辑|-- app.json 小程序公共设置|-- app.wxss 小程序公共样式表 微信，支付宝小程序实现原理概述 - 掘金]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>mina</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apple News+]]></title>
    <url>%2FMurmur%2Fapple-news-plus%2F</url>
    <content type="text"><![CDATA[Apple doesn’t allow advertisers to track you. News+ 的卖点为隐私保护（广告商不能追踪用户行为），过滤信息杂讯并推送给用户严肃且可信的信息。 封面很像《哈利波特》系列中的报纸和壁画，真令人心动！ 更令我感动的是苹果真的在意客户隐私，如今挖掘用户行为推荐算法横行，人们看到的很多信息都是被算法推荐”控制”的。突然想到当今社会如此分裂，或许和这个不无关系。人们往往只看他们想看的，思想会越来越极端，且难以察觉自己正一步步跑偏，只会觉得自己的想法得到所谓的大多数人的认同，不信你看网上都是这样的观点。进而当别人反驳你的时候，甚至认为对方时傻逼，大家都这么想怎么就你喜欢标新立异？（春节回家部分长辈口若悬河般大放厥词自己稍作辩解后就引来他们的迷之鄙视 →_→）]]></content>
      <categories>
        <category>Murmur</category>
      </categories>
      <tags>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NEKO#ΦωΦ 的错误打开方式]]></title>
    <url>%2FMurmur%2FcytusII-neko-is-coming%2F</url>
    <content type="text"><![CDATA[CytusII NEKO 刚升级 Lv25，Æsir 电话，一首好听的新曲子，网络似乎不太稳定，全都是 NEKO。。。。 \(ΦωΦ)/]]></content>
      <categories>
        <category>Murmur</category>
      </categories>
      <tags>
        <tag>game</tag>
        <tag>Cytus</tag>
        <tag>NEKO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[色彩的心情]]></title>
    <url>%2FDrawing%2Fcolor-psychology%2F</url>
    <content type="text"><![CDATA[背景不同文化中的色彩心理有所差异，互联网时代渐渐全球化。 常见色彩心理 黑色：品质、权威、稳重，冷漠、悲伤、防御等消极情感。 白色：简单、纯真、高雅、精致、信任、干净、畅快、朴素。 灰色：睿智、老师、执着、严肃、压抑。 RGB模式，红绿蓝数值相等为中性灰（R=G=B=128，绝对中性灰）。中性灰常用于商业修图、人像精修中调整皮肤质感。 红色：喜庆、自信、斗志、权威、性感。 绿色：生命力、青春、希望、宁静、和平、舒适、安全。 蓝色：永恒、灵性、清新、自由、放松、舒适、宁静、商务。 紫色：优雅、浪漫、高贵、时尚、神秘、梦幻、灵性、妖媚、创造力。 紫+粉，女性化 不要把紫色画深了，避免“闷” 黄色：阳光、青春、活力、时尚、尊贵、年轻、轻快、辉煌、希望。 黄+黑，警戒线 黄色不要拿来当最深的颜色，避免“脏” 更新记录 19-02-03 first commit 参考 色彩心理学 - MBA智库百科 色彩心理学 - Jinkawiki 颜色 - 维基百科，自由的百科全书 网络绘画公开课（直播课程，无特定链接）]]></content>
      <categories>
        <category>Drawing</category>
      </categories>
      <tags>
        <tag>color</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态检查]]></title>
    <url>%2FProgramming%2Fstatic-program-analysis%2F</url>
    <content type="text"><![CDATA[静态检查 与 动态检查静态检查（Static Program Analysis）：以不运行程序的方式对于程序源代码进行检查分析的技术。动态检查（Dynamic Program Analysis）：通过实际运行程序输入测试数据产生预期结果的技术。 检查工具客户端Android -&gt; CheckStyle, Lint, Findbugs, PMDiOS -&gt; Clang Static Analyzer, OCLintReact Native -&gt; ESLint(JavaScript), TSLint (TypeScript) 常见检查工具介绍TSLintTSLint 常见规则 TSLing 优点 速度快； 灵活。可有效避免常见代码错误与潜在bug； 易扩展。可配置自定义规则，控制特定风险。 TSLint 缺点 只有对与错两种等级结果，没有警告等级的提示结果； 无法直接报告规则报错属性，只能依赖其它统计手段； 对于引用到其它文件中的变量、类、方法等，难以通过 AST 语法树进行判定。 to be continued…. 更新记录 19-01-30 first commit 参考 代码静态分析的原理是什么？ - 知乎 静态代码分析工具汇总 - dongwuming的专栏 - CSDN博客 代码的静态与动态分析技术 - FreeBuf专栏·逆向分析 React Native工程中TSLint静态检查工具的探索之路 - 美团技术团队 - SegmentFault 思否 腾讯专项性能测试用动态检查告别重复劳动 - 程序园]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>program analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平平淡淡才是真]]></title>
    <url>%2FMurmur%2Ftodays-meal-for-emiya-family%2F</url>
    <content type="text"><![CDATA[曾经在幽幽暗暗反反复复中追问，才知道平平淡淡从从容容是最真。 *2018年，感谢 Emiya🍚 相伴！ 又快春节放假啦，刚刚我妈发消息，说她已经学会卫宫饭菜单等我回家后让我品尝点评（除了大块牛肉那集的没学，蛋包饭她说失误率较高有时成型不佳）。每月一更新，她比我还要及时。 *去年春节时把 iPad 留给她在玩，除了苹果账号与社交账号是单独设置的其它都共用（母亲文化水平并不高，对一些设置不太了解，共用账号一方面便于她日常使用，另一方面我也能观察平时使用习惯与历史记录，同时还极大化发挥会员使用率哈哈），发现她渐渐熟悉我推荐的各应用与内容后，开始慢慢主动获取，并初步形成了自己的爱好。B站这边她比较偏好画风良好、内容充实有趣的。总体偏好日漫，大多为日常向，国漫她说很多内容较幼稚不太喜欢。此外一些比较硬核或设定复杂的她还在适应中…… 除了影视音乐动画等娱乐内容，其它各类资讯也时不时传达给她，只要她愿意了解，我也乐意将我所思所想跟她分享。不知不觉地，她思想也愈发与我同步，以前或许会起争执的想法现在表示能理解，最大感触就是催婚问题上不再迫切，有时还会帮我跟我爸解释哈哈哈…… 类似事件还有很多就不一一列举了。 *不禁想到，其实母子关系（其它关系也是）多一些理解多一些沟通真的很重要。很多时候，争端的根源往往在于大家都只站在自己的角度而忽视他人的想法，可能表面上了解对方，但事实上真的了解么？ 正如这部卫宫饭的主题一样，简简单单的日常生活才是最珍贵的，幸福就在你我身边！可是现实中大家往往并没有足够珍惜。 先简单写到这里吧。愿大家都能发现周围生活中平凡的美！ 更新记录 19-01-28 first commit 参考 再回首（李翊君演唱歌曲） 卫宫家今天的饭]]></content>
      <categories>
        <category>Murmur</category>
      </categories>
      <tags>
        <tag>TYPE-MOON</tag>
        <tag>anime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heaven's Feel]]></title>
    <url>%2FMurmur%2Ffate-stay-night-heavens-feel%2F</url>
    <content type="text"><![CDATA[心怀希望地等待着，终于等到了 Heaven&#39;s Feel I. presage flower 的内地公映。 概述Fate/stay night 是由 TYPE-MOON 发行的 R18 文字冒险游戏（Galgame），剧本和原画分别为奈须蘑菇和武内崇[^1]。迷失于文字迷宫中，并配合着相称的背景音乐，玩家同一时间不同的抉择将衍生出不同的剧情路线。 剧情线Fate 有三条剧情主线：命运长夜（Fate，Saber 线）、无限剑制（Unlimited Blade Works，UBW 线，凜线）、天之杯（Heaven&#39;s Feel，HF 线，樱线）、以及天国的伊莉雅线。 其中，Fate 线只有一个结局梦的延续，UBW 线包含两个结局：Brilliant Years（True End）和 Sunny Day（Good End），HF 线两个结局： 春天归来（True End）和 樱之梦（Normal End）。此外，全线所有结局通关后方才出现 Saber 线的隐藏结局 – 理想乡阿瓦隆[^2]。 以前玩的是含语音的 Réalta Nua 版本 （语音河蟹版），由于没有参考网上攻略，进度很慢，一次次 Dead End 或 Bad End 进入老虎道场，终于通关了前两条线（前两线通关后才会出现 HF 线入口）。后来由于种种原因没能继续，也算是小小的缺憾吧。 FateSaber 线 – “梦与誓言“，理想化的个人英雄主义。本质是Boy meets Girl主角被过去的悲惨经历所苦，在故事中逐渐承认自我价值的故事。 Saber 因为生前无法拯救国家而献身于夺取圣杯改变命运的涡流之中，后来她意识到现实无可改变，在尘世逗留的短暂幸福时光也让她了解了世俗人生的美好，最终选择放弃执念，坦然回归过去接受命运。 Unlimited Blade WorksUBW 线 – “理想与现实“，英雄的自我矛盾与坚持。本质是主角见到了自己注定破灭的结局，但在同伴的帮助下继续挑战未来的故事。 红 Archer 曾因少年时心怀”正义的伙伴”这一理想而走上漫漫人生路，然而残酷的现实却一次次背离，陷入不断的自我批判与否定中。本打算抹除年少时的”自己”以脱离命运苦海，但在此过程中却被说服，决定继续为了理想而努力。 Heaven’s FeelHF 线 – “爱与救赎“何谓恶，窥探人性的丑陋与残酷，以及纯粹的理想与残酷的现实间妥协的黑暗童话。本质是……的故事（忘记了很多设定，等我回顾完再补坑）当天真的理想面对着无法拯救的人以及纯粹的恶，将作何抉择呢？ 圣杯战争这个背景和仪式本身被放在了探讨的重点上，其真相是什么？其最终目的是什么？至于樱对于士郎的意义，着墨较多，但更重要的是以描绘樱的遭遇为重点来揭示真相。前两条线圣杯战争仅作为背景，第三条线圣杯战争被搬上台面来研究。 三线关系Fate、UBW 和 HF 三个故事的主题是独立的，但故事本身是相互依存的。情绪的渲染、伏笔的埋设、角色的塑造，从 Fate 到 HF，连贯制作而成。同一個人物，在不同世界中的行为，让该角色变得更厚实、更立体。 Heaven’s Feel 剧场版《Fate/stay night [Heaven’s Feel]》是 ufotable 制作的动画电影，由须藤友徳导演和桧山彬编剧，梶浦由记梶负责配乐，剧场版分为三部分播映，第一章《Fate/stay night [Heaven’s Feel] I. presage flower（恶兆之花）》于2017年10月14日上映（内地上映日期为2019年1月11日），第二章《Fate/stay night [Heaven’s Feel] II. lost butterfly（迷途之蝶）》于2019年1月12日上映，第三章《Fate/stay night [Heaven’s Feel] III. spring song》将于2020年春天上映。 presage flower 观影感受咕咕咕…. 情节铺陈相当满意，纯正粉丝向。但对于不熟悉游戏剧情的观众而言，会有些“找不到北”的感觉…… to be continued…. 总结喵喵喵…. 更新记录 19-01-13 update：Heaven’s Feel 剧场版介绍 及 格式链接整理 19-01-10 update：剧情线路补充 及 各剧情线之间关系 19-01-09 post：故事背景和线路介绍 参考资料 TYPE-MOON Official Web Site 「Fate/stay night」公式ページ [Fate/stay night - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/Fate/stay_night 无法忘怀的悲伤，fate stay night三线五结局回顾_动漫星空Fate Stay Night专区 [理论分析] [剧情讨论] fate时间线、平行世界的相关设定 NGA玩家社区 Fate/stay night Heaven’s Feel - 维基百科，自由的百科全书 Fate/stay night: Heaven’s Feel I. presage flower - Wikipedia Fate/stay night: Heaven’s Feel II. lost butterfly - Wikipedia [^1]: 「Fate/stay night」公式ページ[^2]: Fate/stay night – 维基百科]]></content>
      <categories>
        <category>Murmur</category>
      </categories>
      <tags>
        <tag>game</tag>
        <tag>TYPE-MOON</tag>
        <tag>film</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枫(かえで)的日记]]></title>
    <url>%2FReading%2Fkaede-diary%2F</url>
    <content type="text"><![CDATA[十一月五日 我决定今天开始写日记这是枫的日记名字是哥哥起的笔记本和笔 是哥哥买的 枫有爸爸 有妈妈 还有哥哥但我不是很熟悉听说枫没有记忆医生说是”分离性障碍”导致的记忆丧失真难懂 听说不久前的我并不是枫听说枫是个叫”花枫”的人但是 枫并不认识花枫我没见过她果然很难懂 十二月十日 妈妈和爸爸看起来很难受爸爸一直在和医生说话他问了医生好几遍”什么时候能治好”枫这是生病了吗?如果花枫的记忆恢复了枫又会怎样呢枫会跑到别处去吗想到这里我就觉得害怕 哭了出来 三月七日 枫要搬家了哥哥说枫可以自己选想要随身搬过去的东西枫不习惯花枫房间里的东西就决定只带书和书架过去是花枫收集的书 有很多很多那须野也一起搬过去了 到了新的家如果有一天枫治好了病我想花枫会回来的所以枫要在这个新的家里为了把枫当成枫的哥哥而努力成为一个优秀的妹妹 哥哥从春天开始就是高中生了上一所叫”峰之原高中”的学校 哥哥开始打工了回家的时间也变得很晚虽然有点寂寞 但我会努力和那须野一起看家的 哥哥用他第一份工资为我买了熊猫DVD熊猫真可爱 被治愈了 哥哥居然有了女朋友怎么可能但这是真的麻衣姐姐是很好的人是经常上电视的名人 八月二日 今天开始哥哥的朋友要住我们家她叫双叶理央 九月二日 哥哥变成不良少年啦原来我搞错了和香姐姐是麻衣姐姐的妹妹 有件事枫也知道哥哥一直在后悔后悔花枫受欺负的时候他没能帮到她枫知道这点如果枫就这样消失哥哥一定会再次后悔什么都没能做到的所以 枫制定了很多目标是要和哥哥一起实现的目标就算枫消失了也不想让哥哥后悔希望他能自豪的说 帮枫实现了许多愿望比起悲伤的记忆我希望留下更多快乐的 开心的 能让人欢笑的记忆就算枫消失了只要哥哥能笑着想起我来 我就会感到高兴所以枫要加油 我想留给枫的时间不多了拜托了请再给枫一些时间吧多亏了哥哥 枫的目标上画了很多圈一直害怕的外出也做到了要画个大红花还去麻衣姐姐家里玩电车也坐了海边也去了熊猫也看了虽然有点儿赖皮但学校也去过了都是多亏有哥哥在是哥哥让枫充满幸福能成为哥哥的妹妹 枫很幸福现在 过去和将来 我都最喜欢哥哥了明天要在白天去学校]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>none</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Cheat Sheet]]></title>
    <url>%2FTool%2Fmarkdown-syntax-cheat-sheet%2F</url>
    <content type="text"><![CDATA[Basic SyntaxHeading123# H1## H2### H3 Bold1**bold text** Italic1*italicized text* Blockquote1&gt; blockquote Ordered List1231. First item2. Second item3. Third item Unordered List123- First item- Second item- Third item Code1`code` Horizontal Rule1--- Link1[title](https://www.example.com) Image1![alt text](image.jpg) Extended SyntaxTable1234| Syntax | Description || ----------- | ----------- || Header | Title || Paragraph | Text | Fenced Code Block12345&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125; Footnote123Here&apos;s a sentence with a footnote. [^1][^1]: This is the footnote. Heading ID1### My Great Heading &#123;#custom-id&#125; Definition List12term: definition Strikethrough1~~The world is flat.~~ Task List123- [x] Write the press release- [ ] Update the website- [ ] Contact the media 以图表方式打开 更新记录 19-03-24 修改个别单词拼写 18-11-19 初次整理 参考资料 Cheat Sheet | Markdown Guide]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>cheat sheet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 部署时 Permission Denied]]></title>
    <url>%2FTool%2Fhexo-deploy-permission-denied%2F</url>
    <content type="text"><![CDATA[今天对一些文章重新整理，导致部署时出现错误：1234INFO Deploying: gitINFO Clearing .deploy_git folder...FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: EACCES: permission denied, unlink &apos;/Users/Beans/IceWorks/.deploy_git/index.html&apos; 起初将文章重新生成：123hexo cleanhexo ghexo d 发现仍然报错。 后来试着将 文章 与 .deploy_git 清理干净：1234hexo cleansudo rm -rf .deploy_githexo ghexo d 方才正常。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quora，好久不见]]></title>
    <url>%2FMurmur%2Fquora-long-time-no-see%2F</url>
    <content type="text"><![CDATA[上月突然上不去 Quora（网页版总是ERR_CONNECTION_TIMED_OUT，移动版直接搭梯子即可），现在过去一个月了，仍无好转。 只是个小萌新，主要关注“冰火”系列与“魔戒”系列相关讯息，偶尔浏览些科技人文题材的以免英语阅读力退化。一直很喜欢这款应用，里边的内容质量很高，即使存在着语言上的小小隔阂，努力克服就好，同时也是另外一种方式的锻炼与提高。 但这样真的很伤心，虽然有其它手段上去，可毕竟不太便利。 昨天早上突然收到官方邮件，表示一些用户数据疑似被泄露，正在采取有效措施处理，提醒及时关注并更新个人安全设置。 略微有些强迫症，之前应用商店小红点始终停留着，只因每次更新时显示“此项目已不再提供”。终于，决定删掉当前的然后再下载个其他地区的，算作是迂回策略吧。 19-02-16 update：卸载内地应用后下载其他地区的 18-12-05 update：收到官方邮件后及时更新安全信息 18-09-07 first commit]]></content>
      <categories>
        <category>Murmur</category>
      </categories>
      <tags>
        <tag>quora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛云在线处理图片不完全指北]]></title>
    <url>%2FTool%2Fqiniu-cloud-manual-image-processing%2F</url>
    <content type="text"><![CDATA[简介用七牛云存储的图片可直接在线编辑：在图片 URL 后加上相应参数，即可缩放、裁剪图片，或获取图片格式、大小、色彩模型信息，非常方便。 功能： 对图片进行缩略操作 图片缩放、裁剪、旋转 获取图片格式、大小、色彩模型信息 提供数码相机照片的可交换图像文件格式 图片添加图片、文字、图文混合水印 计算图片的平均色调 图片处理常用操作： 注：var 为数字变量，大小自定 限制图片宽度：?imageView2/2/w/var 限制图片大小（仅对 jpg 格式有效）：?imageMogr2/size-limit/var 图片瘦身（在尽可能不影响画质的情况下，将 JPEG、PNG 格式的图片实时压缩，以减小文件体积）：imageslim 设置图片圆角：?roundPic/radius/var 转化图片格式：format/&lt;Format&gt;，Format 取值为 jpg、gif、png、webg 等，默认为原图格式。 基本处理imageView2 123456imageView2/&lt;mode&gt;/w/&lt;LongEdge&gt; /h/&lt;ShortEdge&gt; /format/&lt;Format&gt; /interlace/&lt;Interlace&gt; /q/&lt;Quality&gt; /ignore-error/&lt;ignoreError&gt; 高级处理imageMogr2 123456789101112imageMogr2/auto-orient /thumbnail/&lt;imageSizeGeometry&gt; /strip /gravity/&lt;gravityType&gt; /crop/&lt;imageSizeAndOffsetGeometry&gt; /rotate/&lt;rotateDegree&gt; /format/&lt;destinationImageFormat&gt; /blur/&lt;radius&gt;x&lt;sigma&gt; /interlace/&lt;Interlace&gt; /quality/&lt;quality&gt; /sharpen/&lt;sharpen&gt; /size-limit/&lt;sizeLimit&gt; 瘦身处理imageslim 建议「图片瘦身」操作放在所有其他图片处理操作之后。 水印处理watermark 12345678watermark/1 /image/&lt;encodedImageURL&gt; /dissolve/&lt;dissolve&gt; /gravity/&lt;gravity&gt; /dx/&lt;distanceX&gt; /dy/&lt;distanceY&gt; /ws/&lt;watermarkScale&gt; /wst/&lt;watermarkScaleType&gt; 圆角处理roundPic 123roundPic/radius/&lt;radius&gt; /radiusx/&lt;radiusx&gt; /radiusy/&lt;radiusy&gt; 基本信息imageInfo EXIF信息exif 平均色调imageAve 动图合成animate 12345animate/duration/&lt;duration&gt; /merge/key/&lt;encodedImageKey&gt; /key/&lt;encodedImageKey&gt; ... /effect/&lt;effectType&gt; 更新记录 18-12-27 update：七牛云官网API更新，略作调整 18-07-25 first commit：拟定初稿 参考 七牛云开发者中心-产品手册-图片处理]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>qiniu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 的评论系统之 Valine]]></title>
    <url>%2FTool%2Fhexo-comment-system-valine%2F</url>
    <content type="text"><![CDATA[之前试了试 Disqus 和 Gitalk，出于各方面考虑，最终选择使用 Valine，简洁而美观。 关于 Valine简介Valine 诞生于2017年8月7日，是一款基于 Leancloud 的快速、简洁且高效的无后端评论系统。理论上支持但不限于静态博客，目前已有 Hexo、Jekyll、Typecho、Hugo 等博客程序在使用 Valine。 特性 快速 安全 Emoji 😉 无后端实现 MarkDown 全语法支持 轻量易用 文章阅读量统计 Valine 配置流程注册 LeanCloud 账号LeanCloud 官网 创建应用然后 LeanCloud -&gt; 应用 -&gt; 设置 -&gt; 应用 Key 中查看 App ID 和 App Key。 配置文件../themes/next/_config.yml 文件中，查找 Valine，并添加下面代码中的 appid 和 appkey 字段对应内容。 12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 添加 Web 安全域名为了您的数据安全，请填写 LeanCloud -&gt; 应用 -&gt; 设置 -&gt; 安全中心 中的 Web 安全域名。 Valine 其它配置Valine 头像设置目前 Valine 中采用的是 Gravatar 作为评论列表头像，从 v1.1.7 正式版开始支持(自定义配置 avatar 字段)6种头像表现形式： 参数 表现形式 备注 空字符串&#39;&#39; Gravatar 官方图形 mm 神秘人(一个灰白头像) identicon 抽象几何图形(根据邮箱或昵称生成) monsterid 小怪物 wavatar 用不同面孔和背景组合生成的头像(根据邮箱或昵称生成) retro 八位像素复古头像(根据邮箱或昵称生成) 若 avatar 的值不等于 6 种参数中的一种，则默认为 mm。 Valine 邮件提醒设置设置 LeanCloud LeanCloud -&gt; 应用 -&gt; 设置 -&gt; 邮件模板，按下图设置用于重置密码的邮件主题并保存： 注意：请修改链接为你的博客或网站首页。 12345&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;p&gt;你在 &#123;&#123;appname&#125;&#125; 的评论收到了新的回复，请点击查看：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;你的网址首页链接&quot; style=&quot;display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;&quot;&gt;马上查看&lt;/a&gt;&lt;/p&gt; 初始化 Valine 设置Valine的notify为true即可打开邮件提醒。 注意：发送次数过多，可能会暂时被 Leancloud 屏蔽邮件发送功能注意：由于邮件提醒功能使用的 Leancloud 的密码重置邮件提醒，只能传递昵称、邮箱两个属性，所以邮件提醒链接无法直达指定文章页。请悉知。 注：开启邮件提醒会默认开启验证码选项。 Valine 评论数据管理LeanCloud -&gt; 应用 -&gt; 存储 -&gt; 数据 -&gt; Comment。 更新历史 18-07-21 update：添加 Valine 头像设置 中的参数和表现示例 18-07-17 update：补充 Valine 的 头像设置 和 邮件提醒设置 18-07-16 first commit：拟定初稿 参考资料 第三方服务集成 - NexT 使用文档 介绍 | Valine Home · xCss/Valine Wiki LeanCloud Gravatar - Globally Recognized Avatars]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FOthers%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learning Swift 3]]></title>
    <url>%2FProgramming%2Flearning-swift-3%2F</url>
    <content type="text"><![CDATA[preface16年初时学过 Swift 2.2 版本，由于实际项目中并未使用，长时间后记忆模糊且历经 2.x-&gt;3.x-&gt;4.x 版本迭代，打算重新回顾下知识。本次暂采用人民邮电出版社的《Swift3 开发指南》（很薄的一本），之所以未采用最新版 Swift 4 是因为：①目前尚未找到合适的书籍（有本国外很厚的但贵了些且看原版较慢）；②就个人而言看纸质版效率更高，而电子版易分心。本书为 Swift 3.1，与 Swift 4.x 语法差异后边再单独补充一下即可。 变量和基本数据类型标识符标识符是为变量、常量、方法、函数、枚举、结构体、类和协议等指定的名字。标识符规范：（略） 关键字关键字是一些具有特殊用途的单词。 常用关键字：class, deinit, enum, extension, func, import, init, let, protocol, static, struct, subscript, typealias, var, break, case, continue, default, do else, fallthrough, if, in, for, return, switch, where, while, Nil, nil, as, dynamicType, is, new, super, self, Self, Type, associativity, didSet, willSet, get, infix, inout, left, mutating, none, nonmutating, operator, override, postfix, precedence, prefix, rightset, unowned, unowned(safe), weak. 表达式表达式由操作数和运算符组成。 语句语句是指有返回值的表达式。一条语句结束后可不加分号，也可加分号。 单行注释// 多行注释/**/Swift 支持多行嵌套注释，其它语言不支持。 常量和变量常量let隐式推断 和 显示推断 变量var 数据类型整型、浮点型、布尔型、字符串型、元组型、集合、枚举、结构体、类 整型Swift 提供 8、16、32、64 位形式的有符号及无符号整数。包括：Int8, Int16, Int32, Int64, Int, UInt8, UInt16, UInt32, UInt64, UInt.Int：在 32 位 -&gt; Int32；在 64 位 -&gt; Int64UInt：在 32 位 -&gt; UInt32；在 64 位 -&gt; UInt64 二进制数 0b八进制数 0o十六进制数 0x Swift 中，为便于阅读，可添加下划线。123e.g.var myMoney = 3_360_000 // 一般每隔三位加下划线let phone = 185_1234_5678 布尔型 Booltrue, false 浮点型浮点型主要用来存储小数数值，或范围较大的整数。浮点数 Float双精度浮点数 Double （默认） 浮点型也可采用下划线方法1let pi = 3.141_592_654 字符串型 String声明为let、var来实现不可变字符串、可变字符串 元组型元组型是多个值组成的复合值类型，能够便于管理和计算。元组型由若干个任意类型的数据组成，组成组圆形的数据成为“元素”。1234567891011e.g.let time1 = (2018, 2, 17)let time2 = (year:2018, month:2, day:17)// 可以通过下标访问元组中的数据，也可通过元素名访问// 可以把一个元组的内容分解成单独的常量和变量let (year, month, day) = time2// 如果只需要一部分元组值，分解时可以把要忽略的部分用下划线`_`标记let (year, month, _) = time2 可选型在数据类型后面加上?即可定义一个可选性数据。目的：为了处理可能缺失值的情况。特点：可以有值，也可以没有值。没有值时，为nil。 可选绑定：可选型在 if 或 while 语句中赋值并进行判断强势拆包：读取可选型数据值时，加上!来获取该值隐式拆包：声明可选型数据时将?改为! 数据类型的转换整型之间的转换整型与浮点型之前的转换整型与布尔型之间的转换整型与字符串型之前的转换 常见运算符和表达式算术运算符“+ - * / %” 赋值运算符“= += -= *= /= %=” 关系运算符“== != &gt; &lt; &gt;= &lt;= === !==” 逻辑运算符“! &amp;&amp; ||” 三元运算符“问题 ? 答案1 : 答案2” Nil Coalescing 运算符 （空合运算符）“let c = a ?? b” 相当于 “let c = a! = nil ? a! : b”其中，a 必须为可选型，b 的类型必须与 a 解包后值类型一致 其它自增自减运算符“++ –” 区间运算符闭区间运算符a…b 相当于数学中的”[a, b]”半闭区间运算符..&lt; “[a, b)” 流程控制语句循环语句for-in, while, repear-while for-in 语句遍历集合 范围运算符a…b, a..&lt;b while 语句先执行判断条件，在循环次数未知的情况下使用 repeat-while 语句先执行一次循环体，然后再判断循环条件123repeat &#123; 语句组&#125; while 循环条件 条件语句（分支语句）if语句if, if else, else if switch语句case 分支不需要显式地添加 break 语句每个 case 后可以跟一个值或多个值，多个值之间用逗号分隔每个 case 中至少要有一条语句switch 能支持多种数据类型，包括浮点型、布尔型、字符串型等switch 语句中可使用范围匹配switch 语句中比较元组型数据，使用元组时还可使用值绑定和 where 语句 控制转移语句continue 语句可带标签 break 语句可带标签 fallthrough 语句只能用在switch语句中 return 语句throw 语句流程嵌套字符和字符串Character Unicode 编码Unicode 编码，表现形式\u{n}，包括单字节编码、双字节编码 和 四字节编码。 字符串常见操作123456789str.character.count&gt; &lt; &gt;= &lt;= == != 判断依据为 Unicode 编码值大小，且从第1位依次比较（跟字符串长度无关）str.hasPrefix(String), str.hasSuffix(String)upercased(), lowercased(), capitalizedstr.insert(newElement: Character, at:Index), str.startIndex, str.endIndex e.g. str[str.startIndex]str.append(), +, str.append(String)str.remove(at:Index), str.removeSubrange(bounds:Range&lt;Index&gt;), str.removeAll()str.subString(from:Index), str.subString(to:Index), str.subString(with:Range&lt;Index&gt;)str.replaceSubrange(bounds:Range&lt;Index&gt;, with:String) ... String 与 NSString 关系String 是值类型，而 NSString 是类。 可使用as运算符进行类型转换 Collection 类型数组数组是由一组类型相同元素构成的有序数据集合。 数组的创建类型格式：Array&lt;ElementType&gt; 或 [ElementType]。其中前者为泛型写法，后者为简写方式。 let、var 分别声明为不可变数组、可变数组 在没有明确指定数组类型时，可以在数组中存放不同类型的元素。 多个相同元素时，可以快速创建 e.g. Array(repeating:0.0, count:3) 数组的访问通过下标访问对数组中单个元素访问for-in 循环遍历数组使用全局的 enumerate 函数获取每个元素的索引和值123for (index, value) in languageList.enumerated() &#123; print(&quot;Item \(index + 1): \(value)&quot;)&#125; count, isEmpty 数组的编辑追加 append(Element), “+”操作符插入 insert(newElement:Element, at:Index)删除 remove(at:Int), removeAll(), removeLast()替换 通过下标赋值来修改、替换 数组的复制数组属于值类型，值类型在赋值或参数传递时会发生复制行为，赋予的值或传递的参数是一个副本。而引用类型在赋值或参数传递时不会发生复制行为，赋予的值或传递的参数是一个引用。 Array 与 NSArray 的关系NSArray 是类类型，而 Array 是结构体类型。前者为引用类型，后者为值类型。一个 NSArray 对象桥接之后的结果是 [AnyObject]数组（保存 AnyObject 元素的 Array 数组） 可使用as!进行转换 字典字典有键和值两部分构成，是一种存储多个类型相同的值的容器，每个值都和唯一的键相对应。 类型格式 Dictionary&lt;KeyType, ValueType&gt; 集合]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bill of Rights 权利法案]]></title>
    <url>%2FLanguage%2Fbill-of-rights%2F</url>
    <content type="text"><![CDATA[Amendment 1Congress shall make no law respecting an establishment of religion, or prohibiting the free exercise therrof; or abridging the freedom of speech, or of the press; or the right of the people peaceably to assemble, and to petition the Government for a redress of grievances. 国会不得制定关于下列事项的法律：确立国教或禁止信教自由；剥夺言论自由或出版自由；或剥夺人民和平集会和向政府请愿伸冤的权利。 Comments: The First Amendment guarantees freedom of speech, freedom of the press, and freedom of association and assembly. It also protects the rights of citizens to worship as they please and the right not to be forced to support someone else’s religion. The First Amendment also provides for the right to demand a change in government policies. Amendment 2A well regulated Militia, being necessary to the security of a free State, the right of the people to keep and bear Arms, shall not be infringed. 纪律严明的民兵是暴涨自由州的安全所必需的，人民持有和携带武器的权利不可侵犯。 Amendment 3No Soldier shall, in time of peace be quartered in any house, without the consent of the Owner, nor in time of war, but in a manner to be prescribed by law. 未经房主同意，士兵平时不得驻扎在任何住宅；除依法律规定的方式，战时也不得驻扎。 Amendment 4The right of the people to be secure in their persons, houses, papers, and effects, against unreasonable searches and seizures, shall not be violated, and no Warrants shall issue, but upon probable cause, supported by Oath or affirmation, and particularly describing the place to be searched, and the persons or things to be seized. 人民的人身、住宅、文件和财产不受无理搜查和扣押的权利，不得侵犯。除依据可能成立的理由，以宣誓或代誓宣言保证，并详细说明搜查地点和扣押的人或物，不得发出搜查和扣押状。 Amendment 5No person shall be held to answer for a capital, or otherwise infamous crime, unless on a presentment or indictment of a Grand Jury, except in cases arising in the land or naval forces, or in the Militia, when in actual service in time of War or public danger; nor shall any person be subject for the same offence to be twice put in jeopardy of life or limb; nor shall be compelled in any criminal case to be a witness against hhimself, nor be deprived of life, liberty, or property, without due process of law; nor shall private property be taken for public use, without just compensation. 除非根据大陪审团的报告或起诉书，任何人不受死罪或其他重罪的审判，但发生在陆、海军中或发生在战时或出现公共危险时服役的民兵中的案件除外；任何人不得因同一犯罪行为而两次遭受生命或身体的危害；不得在任何刑事案件中被迫自证其罪；不经正当法律程序，不得被剥夺生命、自由或财产。不给予公平赔偿，私有财产不得充作公用。 ….]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC, MVVM & ReactiveCocoa]]></title>
    <url>%2FProgramming%2Fmvc-mvvm-reactivecocoa%2F</url>
    <content type="text"><![CDATA[MVC 经常被调侃为 Massive View Controller MVVM view ：由 MVC 中的 view 和 controller 组成，负责 UI 的展示，绑定 viewModel 中的属性，触发 viewModel 中的命令； viewModel ：从 MVC 的 controller 中抽取出来的展示逻辑，负责从 model 中获取 view 所需的数据，转换成 view 可以展示的数据，并暴露公开的属性和命令供 view 进行绑定； model ：与 MVC 中的 model 一致，包括数据模型、访问数据库的操作和网络请求等； binder ：在 MVVM 中，声明式的数据和命令绑定是一个隐含的约定，它可以让开发者非常方便地实现 view 和 viewModel 的同步，避免编写大量繁杂的样板化代码。 ReactiveCocoa尽管，在 iOS 开发中，系统并没有提供类似的框架可以让我们方便地实现 binder 功能，不过，值得庆幸的是，GitHub 开源的 RAC ，给了我们一个非常不错的选择。 RAC 是一个 iOS 中的函数式响应式编程框架，它受 Functional Reactive Programming 的启发，是在开发 GitHub for Mac 过程中的一个副产品，它提供了一系列用来组合和转换值流的 API 。 我们可以使用 RAC 来在 view 和 viewModel 之间充当 binder 的角色，优雅地实现两者之间的同步。此外，我们还可以把 RAC 用在 model 层，使用 Signal 来代表异步的数据获取操作，比如读取文件、访问数据库和网络请求等。 from MVC to MVVM我们只要将 MVC 中的 controller 中的展示逻辑抽取出来，放置到 viewModel 中，然后通过一定的技术手段，比如 RAC 来同步 view 和 viewModel ，就完成了 MVC 到 MVVM 的转变。 优点: 由于展示逻辑被抽取到了 viewModel 中，所以 view 中的代码将会变得非常轻量级； 由于 viewModel 中的代码是与 UI 无关的，所以它具有良好的可测试性； 对于一个封装了大量业务逻辑的 model 来说，改变它可能会比较困难，并且存在一定的风险。在这种场景下，viewModel 可以作为 model 的适配器使用，从而避免对 model 进行较大的改动。 对于 MVVM 来说，我们可以把 view 看作是 viewModel 的可视化形式，viewModel 提供了 view 所需的数据和命令。因此，viewModel 的可测试性可以帮助我们极大地提高应用的质量。 参考MVVM With ReactiveCocoa, by 雷纯锋]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>MVVM</tag>
        <tag>ReactiveCocoa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactiveCocoa]]></title>
    <url>%2FProgramming%2Freactivecocoa-source-code-architecture%2F</url>
    <content type="text"><![CDATA[Version1234ReactiveCocoa 的版本演进&lt;= v2.5 ：Objective-C v3.x ：Swift 1.2 v4.x ：Swift 2.x 层次结构 四大核心组件: 信号源：RACStream 及其子类； 订阅者：RACSubscriber 的实现类及其子类； 调度器：RACScheduler 及其子类； 清洁工：RACDisposable 及其子类。 其中，信号源又是最核心的部分，其他组件都是围绕它运作的。 对于一个应用来说，绝大部分的时间都是在等待某些事件的发生或响应某些状态的变化，比如用户的触摸事件、应用进入后台、网络请求成功刷新界面等等，而维护这些状态的变化，常常会使代码变得非常复杂，难以扩展。而 ReactiveCocoa 给出了一种非常好的解决方案，它使用信号来代表这些异步事件，提供了一种统一的方式来处理所有异步的行为，包括代理方法、block 回调、target-action 机制、通知、KVO 等 1234567891011121314151617181920212223242526// 代理方法[[self rac_signalForSelector:@selector(webViewDidStartLoad:) fromProtocol:@protocol(UIWebViewDelegate)] subscribeNext:^(id x) &#123; // 实现 webViewDidStartLoad: 代理方法 &#125;];// target-action[[self.avatarButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *avatarButton) &#123; // avatarButton 被点击了 &#125;];// 通知[[[NSNotificationCenter defaultCenter] rac_addObserverForName:kReachabilityChangedNotification object:nil] subscribeNext:^(NSNotification *notification) &#123; // 收到 kReachabilityChangedNotification 通知 &#125;];// KVO[RACObserve(self, username) subscribeNext:^(NSString *username) &#123; // 用户名发生了变化&#125;]; 真正强大的地方在于我们可以对这些不同的信号进行任意地组合和链式操作，从最原始的输入 input 开始直至得到最终的输出 output 为止： 12345678910111213[[[RACSignal combineLatest:@[ RACObserve(self, username), RACObserve(self, password) ] reduce:^(NSString *username, NSString *password) &#123; return @(username.length &gt; 0 &amp;&amp; password.length &gt; 0); &#125;] distinctUntilChanged] subscribeNext:^(NSNumber *valid) &#123; if (valid.boolValue) &#123; // 用户名和密码合法，登录按钮可用 &#125; else &#123; // 用户名或密码不合法，登录按钮不可用 &#125; &#125;]; 信号源在 ReactiveCocoa 中，信号源代表的是随着时间而改变的值流，这是对 ReactiveCocoa 最精准的概括，订阅者可以通过订阅信号源来获取这些值： Streams of values over time. RACStreamRACStream 是 ReactiveCocoa 中最核心的类，代表的是任意的值流，它是整个 ReactiveCocoa 得以建立的基石。 事实上，RACStream 是一个抽象类，通常情况下，我们并不会去实例化它，而是直接使用它的两个子类 RACSignal 和 RACSequence 。 RACSignalRACSignal 代表的是未来将会被传送的值，它是一种 push-driven 的流。 RACSignal 可以向订阅者发送三种不同类型的事件： next ：RACSignal 通过 next 事件向订阅者传送新的值，并且这个值可以为 nil ； error ：RACSignal 通过 error 事件向订阅者表明信号在正常结束前发生了错误； completed ：RACSignal 通过 completed 事件向订阅者表明信号已经正常结束，不会再有后续的值传送给订阅者。 注意，ReactiveCocoa 中的值流只包含正常的值，即通过 next 事件传送的值，并不包括 error 和 completed 事件，它们需要被特殊处理。通常情况下，一个信号的生命周期是由任意个 next 事件和一个 error 事件或一个 completed 事件组成的。 RACSignal 并非只有一个类，事实上，它的一系列功能是通过类簇来实现的。除去我们将在下节介绍的 RACSubject 及其子类外，RACSignal 还有五个用来实现不同功能的私有子类： RACEmptySignal：空信号，用来实现 RACSignal 的 +empty 方法； RACReturnSignal：一元信号，用来实现 RACSignal 的 +return: 方法； RACDynamicSignal：动态信号，使用一个 block 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例； RACErrorSignal：错误信号，用来实现 RACSignal 的 +error: 方法； RACChannelTerminal：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。 对于 RACSignal 类簇来说，最核心的方法莫过于 -subscribe: 了，这个方法封装了订阅者对信号源的一次订阅过程，它是订阅者与信号源产生联系的唯一入口。因此，对于 RACSignal 的所有子类来说，这个方法的实现逻辑就代表了该子类的具体订阅行为，是区分不同子类的关键所在。同时，这也是为什么 RACSignal 中的 -subscribe: 方法是一个抽象方法，并且必须要让子类实现的原因： 1234- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123; NSCAssert(NO, @"This method must be overridden by subclasses"); return nil;&#125; RACSubjectRACSubject 代表的是可以手动控制的信号，我们可以把它看作是 RACSignal 的可变版本，就好比 NSMutableArray 是 NSArray 的可变版本一样。RACSubject 继承自 RACSignal ，所以它可以作为信号源被订阅者订阅，同时，它又实现了 RACSubscriber 协议，所以它也可以作为订阅者订阅其他信号源，这个就是 RACSubject 为什么可以手动控制的原因： RACSubject 也有三个用来实现不同功能的子类： RACGroupedSignal：分组信号，用来实现 RACSignal 的分组功能； RACBehaviorSubject：重演最后值的信号，当被订阅时，会向订阅者发送它最后接收到的值； RACReplaySubject：重演信号，保存发送过的值，当被订阅时，会向订阅者重新发送这些值。 RACSubject 的功能非常强大，但是太过灵活，也正是因为如此，我们只有在迫不得已的情况下才会使用它。一旦过度使用，就会使代码变得非常复杂，难以理解。 RACSequenceRACSequence 代表的是一个不可变的值的序列，与 RACSignal 不同，它是 pull-driven 类型的流。从严格意义上讲，RACSequence 并不能算作是信号源，因为它并不能像 RACSignal 那样，可以被订阅者订阅，但是它与 RACSignal 之间可以非常方便地进行转换。 从理论上说，一个 RACSequence 由两部分组成： head：指的是序列中的第一个对象，如果序列为空，则为 nil ； tail：指的是序列中除第一个对象外的其它所有对象，同样的，如果序列为空，则为 nil 。 事实上，一个序列的 tail 仍然是一个序列，如果我们将序列看作是一条毛毛虫，那么 head 和 tail 可表示如下： 同样的，一个序列的 tail 也可以看作是由 head 和 tail 组成，而这个新的 tail 又可以继续看作是由 head 和 tail 组成，这个过程可以一直进行下去。而这个就是 RACSequence 得以建立的理论基础，所以一个 RACSequence 子类的最小实现就是 head 和 tail 总的来说，RACSequence 存在的最大意义就是为了简化 Objective-C 中的集合操作： Simplifying Collection Transformations: Higher-order functions like map, filter, fold/reduce are sorely missing from Foundation. 12345678910// 通常实现NSMutableArray *results = [NSMutableArray array];for (NSString *str in strings) &#123; if (str.length &lt; 2) &#123; continue; &#125; NSString *newString = [str stringByAppendingString:@"foobar"]; [results addObject:newString];&#125; 12345678// 使用RACSequence实现RACSequence *results = [[strings.rac_sequence filter:^ BOOL (NSString *str) &#123; return str.length &gt;= 2; &#125;] map:^(NSString *str) &#123; return [str stringByAppendingString:@"foobar"]; &#125;]; 因此，我们可以非常方便地使用 RACSequence 来实现集合的链式操作，直到得到你想要的最终结果为止。除此之外，使用 RACSequence 的另外一个主要好处是，RACSequence 中包含的值在默认情况下是懒计算的，即只有在真正用到的时候才会被计算，并且只会计算一次。也就是说，如果我们只用到了一个 RACSequence 中的部分值的时候，它就在不知不觉中提高了我们应用的性能。 同样的，RACSequence 的一系列功能也是通过类簇来实现的，它共有九个用来实现不同功能的私有子类： RACUnarySequence：一元序列，用来实现 RACSequence 的 +return: 方法； RACIndexSetSequence：用来遍历索引集； RACEmptySequence：空序列，用来实现 RACSequence 的 +empty: 方法； RACDynamicSequence：动态序列，使用 blocks 来动态地实现一个序列； RACSignalSequence：用来遍历信号中的值； RACArraySequence：用来遍历数组中的元素； RACEagerSequence：非懒计算的序列，在初始化时立即计算所有的值； RACStringSequence：用来遍历字符串中的字符； RACTupleSequence：用来遍历元组中的元素。 RACSequence 为类簇提供了统一的对外接口，对于使用它的客户端代码来说，完全不需要知道私有子类的存在，很好地隐藏了实现细节。另外，值得一提的是，RACSequence 实现了快速枚举的协议 NSFastEnumeration 订阅者为了获取信号源中的值，我们需要对信号源进行订阅。在 ReactiveCocoa 中，订阅者是一个抽象的概念，所有实现了 RACSubscriber 协议的类都可以作为信号源的订阅者。 RACSubscriber四个方法必须实现的方法中, -sendNext: 、-sendError: 和 -sendCompleted` 分别用来从 RACSignal 接收 next 、error 和 completed 事件，而-didSubscribeWithDisposable: 则用来接收代表某次订阅的 disposable 对象。 订阅者对信号源的一次订阅过程可以抽象为：通过 RACSignal 的 -subscribe: 方法传入一个订阅者，并最终返回一个 RACDisposable 对象的过程： 注意：在 ReactiveCocoa 中并没有专门的类 RACSubscription 来代表一次订阅，而间接地使用 RACDisposable 来充当这一角色。因此，一个 RACDisposable 对象就代表着一次订阅，并且我们可以用它来取消这次订阅. 除了 RACSignal 的子类外，还有两个实现了 RACSubscriber 协议的类，RACSubscriver 和 RACPassthroughSubscriber。 其中，RACSubscriber 类的名字与 RACSubscriber 协议的名字相同，这跟 Objective-C 中的 NSObject 类的名字与 NSObject 协议的名字相同是一样一样的，除了名字相同外，然并卵。通常来说，RACSubscriber 类充当的角色就是信号源的真正订阅者，它老老实实地实现了 RACSubscriber 协议。 既然 RACSubscriber 类就是真正的订阅者，那么 RACPassthroughSubscriber 类又是干嘛用的呢？原来，在 ReactiveCocoa 中，一个订阅者是可以订阅多个信号源的，也就是说它会拥有多个 RACDisposable 对象，并且它可以随时取消其中任何一个订阅。为了实现这个功能，ReactiveCocoa 就引入了 RACPassthroughSubscriber 类，它是 RACSubscriber 类的一个装饰器，封装了一个真正的订阅者 RACSubscriber 对象，它负责转发所有事件给这个真正的订阅者，而当此次订阅被取消时，它就会停止转发：1234567891011121314- (void)sendNext:(id)value &#123; if (self.disposable.disposed) return; [self.innerSubscriber sendNext:value];&#125;- (void)sendError:(NSError *)error &#123; if (self.disposable.disposed) return; [self.innerSubscriber sendError:error];&#125;- (void)sendCompleted &#123; if (self.disposable.disposed) return; [self.innerSubscriber sendCompleted];&#125; 事实上，在 ReactiveCocoa 中，我们倾向于隐藏订阅者，因为外界根本不需要知道订阅者的存在，这是内部的实现细节。这样做的主要目的是进一步简化信号源的订阅逻辑，客户端代码只需要关心它所需要的值就可以了，根本不需要关心内部的订阅过程。 RACMulticastConnection通常来说，我们在订阅一个信号源的过程中可能会产生副作用或者消耗比较大的资源，比如修改全局变量、发送网络请求等。这个时候，我们往往需要让多个订阅者之间共享一次订阅 RACMulticastConnection 通过一个标志 _hasConnected 来保证只对 sourceSignal 订阅一次，然后对外暴露一个 RACSubject 类型的 signal 供外部订阅者订阅。这样一来，不管外部订阅者对 signal 订阅多少次，我们对 sourceSignal 的订阅至多只会有一次： 调度器有了信号源和订阅者，我们还需要由调度器来统一调度订阅者订阅信号源的过程中所涉及到的任务，这样才能保证所有的任务都能够合理有序地执行。 RACSchedulerRACScheduler 在 ReactiveCocoa 中就是扮演着调度器的角色，本质上，它就是用 GCD 的串行队列 来实现的，并且支持取消操作。是的，在 ReactiveCocoa 中，并没有使用到 NSOperationQueue 和 NSRunloop 等技术，RACScheduler 也只是对 GCD 的简单封装而已。 同样的，RACScheduler 的一系列功能也是通过类簇来实现的，除了用来测试的子类外，总共还有四个私有子类： RACImmediateScheduler：立即执行调度的任务，这是唯一一个支持同步执行的调度器； RACQueueScheduler：一个抽象的队列调度器，在一个 GCD 串行列队中异步调度所有任务； RACTargetQueueScheduler：继承自 RACQueueScheduler ，在一个以一个任意的 GCD 队列为 target 的串行队列中异步调度所有任务； RACSubscriptionScheduler：一个只用来调度订阅的调度器。 值得一提的是，在 RACScheduler 中有一个非常特殊的方法：- (RACDisposable *)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock;这个方法的作用非常有意思，它可以将递归调用转换成迭代调用，这样做的目的是为了解决深层次的递归调用可能会带来的堆栈溢出问题。 清洁工在订阅者订阅信号源的过程中，可能会产生副作用或者消耗一定的资源，所以当我们在取消订阅或者完成订阅时，我们就需要做一些资源回收和垃圾清理的工作。 RACDisposable在订阅者订阅信号源的过程中，可能会产生副作用或者消耗一定的资源，所以当我们在取消订阅或者完成订阅时，我们就需要做一些资源回收和垃圾清理的工作。 RACDisposable RACDisposable 在 ReactiveCocoa 中就充当着清洁工的角色，它封装了取消和清理一次订阅所必需的工作。它有一个核心的方法 -dispose ，调用这个方法就会执行相应的清理工作，这有点类似于 NSObject 的 -dealloc 方法。RACDisposable 总共有四个子类： RACSerialDisposable：作为 disposable 的容器使用，可以包含一个 disposable 对象，并且允许将这个 disposable 对象通过原子操作交换出来； RACKVOTrampoline：代表一次 KVO 观察，并且可以用来停止观察； RACCompoundDisposable：跟 RACSerialDisposable 一样，RACCompoundDisposable 也是作为 disposable 的容器使用。不同的是，它可以包含多个 disposable 对象，并且支持手动添加和移除 disposable 对象，有点类似于可变数组 NSMutableArray 。而当一个 RACCompoundDisposable 对象被 disposed 时，它会调用其所包含的所有 disposable 对象的 -dispose 方法，有点类似于 autoreleasepool 的作用; RACScopedDisposable：当它被 dealloc 的时候调用本身的 -dispose 方法。 Summary通过介绍 ReactiveCocoa 四大核心组件，对它的架构有了宏观上的认识。它建立于 Monad 的概念之上，然后围绕其搭建了一系列完整的配套组件，它们共同支撑了 ReactiveCocoa 的强大功能。尽管，ReactiveCocoa 是一个重型的函数式响应式框架，但是它并不会对我们现有的代码构成侵略性，我们完全可以在一个单独的类中使用它，哪怕只是简单的一行代码，也是没有问题的。 参考 ReactiveCocoa Design Guidelines ReactiveCocoa v2.5 源码解析之架构总览, by 雷纯锋]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>ReactiveCocoa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式编程 (Reactive Programming)]]></title>
    <url>%2FProgramming%2Freactive-programming%2F</url>
    <content type="text"><![CDATA[相关框架: Rx, Bacon.js, RAC 响应式编程响应式思维 响应式编程, 为异步数据流编程, 是一种面向数据流和变化传播的编程范式, 数据更新是相关联的 创建(create)流, 将流进行组合(combine) 和 过滤(filter); input, merge, filter, map 一个流就是一个将要发生的以时间为序的事件序列. 它能发射出三种不同的信号: 一个数据值(data value, 某种类型的), 一个错误(error) 或 一个完成(completed)的信号 监听流的行为叫做订阅, 观察者设计模式 e.g. 假设实现一个双击事件流(两次或两次以上) 响应式编程提高了代码的抽象层次, 这样就可以专注于业务逻辑的事件定义, 而不是尝尝捣鼓那些大量的实现细节. RP的代码可能会更简洁清晰. Reactive CocoaiOS开发中事件: Target, Delegate, KVO, 通知, 时钟, 网络异步回调 ReactiveCocoa用信号接管了iOS中的所有事件. RAC特点: 通过block函数式+链式的编程, 可以让所有相关的代码继承在一起.使用时需要注意循环引用, @weakify(self) / @strongify(self) 组合解除循环引用 FRP或RAC的一些简图 参考通俗解释什么是响应式编程？函数式反应型编程(FRP) —— 实时互动应用开发的新思路, by 邓际锋]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>ReactiveCocoa</tag>
        <tag>FRP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[断言]]></title>
    <url>%2FProgramming%2Fobjective-c-debug-nsassert%2F</url>
    <content type="text"><![CDATA[断言断言 (assertion) 是指在开发期间使用的, 让程序在运行时进行自检的代码 (通常是一个子程序或宏. 若断言为真, 则表明程序运行正常; 而断言为假, 则意味着它已经在代码中发现了意料之外的错误. 断言对于大型的复杂程序或可靠性要求极高的程序来说尤其有用. 断言使用的指导性建议: 用错误处理代码来处理预期会发生的状况, 用断言来处理绝不应该发生的状况 避免把需要执行的代码放到断言中 用断言来注解并验证前条件和后条件 对于高健壮性的代码, 应该先使用断言再处理错误 NSAssert 和 assert 都是断言, 主要的差别在于 assert 在断言失败的时候只是简单的终止程序, 而 NSAssert 会报告出错误信息并且打印出来, 因此应尽量使用 NSAssert. iOS 中常用的是两对断言, NSAssert/NSCAssert 和 NSParameterAssert/NSCparameterAssert. NSAssertionHandlerObjective-C 中的断言处理使用的是 NSAssertionHandler: 每个线程拥有它自己的断言处理器, 它是 NSAssertionHandler 类的实例对象. 当被调用时, 一个断言处理器打印一条包含方法和类名（或者函数名）的错误信息. 然后抛出一个 NSInternalInconsistencyException 异常. NSAssert 和 NSCAssert123456789101112131415161718192021222324252627282930313233// NSAssert#if !defined(_NSAssertBody)#define NSAssert(condition, desc, ...) \ do &#123; \ __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \ if (__builtin_expect(!(condition), 0)) &#123; \ NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \ __assert_file__ = __assert_file__ ? __assert_file__ : @"&lt;Unknown File&gt;"; \ [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \ object:self file:__assert_file__ \ lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \ &#125; \ __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \ &#125; while(0)#endif// NSCAssert#if !defined(_NSCAssertBody)#define NSCAssert(condition, desc, ...) \ do &#123; \ __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \ if (__builtin_expect(!(condition), 0)) &#123; \ NSString *__assert_fn__ = [NSString stringWithUTF8String:__PRETTY_FUNCTION__]; \ __assert_fn__ = __assert_fn__ ? __assert_fn__ : @"&lt;Unknown Function&gt;"; \ NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \ __assert_file__ = __assert_file__ ? __assert_file__ : @"&lt;Unknown File&gt;"; \ [[NSAssertionHandler currentHandler] handleFailureInFunction:__assert_fn__ \ file:__assert_file__ \ lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \ &#125; \ __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \ &#125; while(0)#endif NSParameterAssert 和 NSCParameterAssert12345// NSParameterAssert#define NSParameterAssert(condition) NSAssert((condition), @"Invalid parameter not satisfying: %@", @#condition)// NSCParameterAssert#define NSCParameterAssert(condition) NSCAssert((condition), @"Invalid parameter not satisfying: %@", @#condition) 根据定义, 第一组 (NSAssert / NSCAssert) 是针对条件的断言, 第二组 (NSParameterAssert / NSCparameterAssert) 是处理参数是否存在的断言; 其中, 每组前者是适用于 Object-C 的方法, _cmd 和 self 与运行时有关, 后者是适用于 C 的函数. NSAssert 和 assertNSAssert 和 assert 都是断言, 主要差别为 assert 在断言失败的时候只是简单的终止程序, 而 NSAssert 会报告错误信息并且打印出来. Xcode 编译从 Xcode 4.2 开始，发布构建默认关闭了断言, 它是通过定义 NS_BLOCK_ASSERTIONS 宏实现的. 也就是说, 当编译 release 版本时, 任何调用 NSAssert 等的地方都被有效的移除了. (在 Debug 情况下, 所有 NSAssert 都会被执行, 在 Release 下不希望 NSAssert 被执行, 通常在 Release 中将断言设置成禁用.设置方法: 在 Build Settings 菜单, 搜索 Preprocessor Macros 项, 其下面有一个选择, 用于程序生成配置: Debug 版和 Release 版. 选择 Release 项, 添加一个规则: NS_BLOCK_ASSERTIONS, 即不进行断言检查.) 自定义 NSAssertionHandlerNSAssertionHandler 类中, 有两个需要在子类中实现的方法: - (void)handleFailureInMethod:... (当 NSAssert / NSParameterAssert 失败时调用) 和 - (void)handleFailureInFunction:... (当 NSCAssert / NSCParameterAssert 失败时调用). 每个线程都可以指定断言处理器.如果 NSAssert 和 NSCAssert 条件评估为错误, 会向 NSAssertionHandler 实例发送一个表示错误的字符串. 如果想设置一个 NSAssertionHandler 的子类来处理失败的断言, 在线程的 threadDictionary 对象中设置 NSAssertionHandlerKey 字段. 这样我们就完成在当前线程中使用自定义断言处理器的配置, 那么接下来, 如果有和我们条件不同的情况都直接会回调对应着的那两个失败的方法.(有时也可以在自定义 NSAssertionHandler 中重写上述两个失败的回调方法, 在这里执行我们想要抛出的错误 – 打印或者直接报错, 可以使得出现断言时, 控制台输出错误, 但是程序仍然继续运行, 不会强制退出程序): 1234567891011121314151617#import "MyAssertHandler.h"@implementation MyAssertHandler// 处理 Objective-C 的断言- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,...&#123; NSLog(@"NSAssert Failure: Method %@ for object %@ in %@#%li", NSStringFromSelector(selector), object, fileName, (long)line);&#125;// 处理 C 的断言- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,...&#123; NSLog(@"NSCAssert Failure: Function (%@) in %@#%li", functionName, fileName, (long)line);&#125;@end 1234NSAssertionHandler *myAssertHandler = [[MyAssertHandler alloc] init];//给当前的线程[[[NSThread currentThread] threadDictionary] setValue:myAssertHandler forKey:NSAssertionHandlerKey]; 注意事项仔细观察 NSAssert 宏定义, 会发现其中包含 self, 有 self 的地方一定要注意 block 循环引用问题. 那如果想在 block 中使用断言该怎么办呢? 可以用 NSCAssert 替换 NSAssert, 用 NSCParameterAssert 替换 NSParameterAssert. 参考 NSAssert - Foundation | Apple Developer Documentation iOS开发中断言的使用—NSAssert() 断言(NSAssert)的使用]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>NSAssert</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[update CocoaPods (from v1.0.0 to v1.3.1)]]></title>
    <url>%2FTool%2Fupdate-cocoapods-ruby-source-error%2F</url>
    <content type="text"><![CDATA[这次更新主要涉及到 ruby 源更新的问题 查看 ruby 源 gem sources -l 移除原有 ruby 源（跟上一步查看的保持一致） gem sources --remove https://ruby.taobao.org/ 添加国内最新 ruby 源 gem sources -a https://gems.ruby-china.org/ 查看是否添加成功 gem sources -l 安装 CocoaPods sudo gem install -n /usr/local/bin cocoapods 安装完成后查看 pod 版本 pod --version 更新 Podspec 索引文件，创建本地索引库（耗时可能较长） pod setup 接下来就可正常使用啦 2017.11.16 update contents 上周将系统升级到了 macOS High Sierra(10.13.1)，今天突然发现 CocoaPods 不能正常使用了。QAQ 1-bash: /usr/local/bin/pod: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby: bad interpreter: No such file or directory 解决方法： 升级 ruby sudo gem update --system 重新安装 CocoaPods sudo gem install -n /usr/local/bin cocoapods]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSPatch – 动态更新iOS APP]]></title>
    <url>%2FProgramming%2Fhotfix-jspatch%2F</url>
    <content type="text"><![CDATA[JSPatch 只需在项目中引入极小的引擎，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，获得脚本语言的能力：动态更新APP，替换项目原生代码修复 bug。 用途是否有过这样的经历：新版本上线后发现有个严重的 bug，可能会导致 crash 率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复 bug 然后提交等待漫长的 AppStore 审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次 bug 的修复。 使用 JSPatch 可以解决这样的问题，只需在项目中引入 JSPatch，就可以在发现bug时下发 JS 脚本补丁，替换原生方法，无需更新应用即时修复 bug。 范例暂略 原理JSPatch 用 iOS 内置的 JavaScriptCore.framework 作为 JS 引擎，但没有用它 JSExport 的特性进行 JS-OC 函数互调，而是通过 Objective-C Runtime，从 JS 传递要调用的类名函数名到 Objective-C，再使用 NSInvocation 动态调用对应的 OC 方法。详细的实现原理以及实现过程中遇到的各种坑和 hack 方法会另有文章介绍。 方案对比目前已经有一些方案可以实现动态打补丁，例如 WaxPatch，可以用 Lua 调用 OC 方法，相对于 WaxPatch，JSPatch 的优势是： 1.JS语言 JS比Lua 在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS 是不二之选。 2.符合 Apple 规则 JSPatch 更符合 Apple 的规则。iOS Developer Program License Agreement 里 3.3.2 提到不可动态下发可执行代码，但通过苹果 JavaScriptCore.framework 或 WebKit 执行的代码除外，JS 正是通过 JavaScriptCore.framework 执行的。 3.小巧 使用系统内置的 JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。 4.支持 block wax 在几年前就停止了开发和维护，不支持 Objective-C 里 block 跟 Lua 程序的互传，虽然一些第三方已经实现 block，但使用时参数上也有比较多的限制。 相对于 WaxPatch，JSPatch 劣势在于不支持 iOS6，因为需要引入 JavaScriptCore.framework。另外目前内存的使用上会高于 wax，持续改进中。 风险JSPatch 让脚本语言获得调用所有原生 OC 方法的能力，不像 web 前端把能力局限在浏览器，使用上会有一些安全风险： 若在网络传输过程中下发明文 JS，可能会被中间人篡改 JS 脚本，执行任意方法，盗取 APP 里的相关信息。可以对传输过程进行加密，或用直接使用 https 解决。 若下载完后的 JS 保存在本地没有加密，在未越狱的机器上用户也可以手动替换或篡改脚本。这点危害没有第一点大，因为操作者是手机拥有者，不存在 APP 内相关信息被盗用的风险。若要避免用户修改代码影响 APP 运行，可以选择简单的加密存储。 其他用途JSPatch 可以动态打补丁，自由修改 APP 里的代码，理论上还可以完全用 JSPatch 实现一个业务模块，甚至整个 APP，跟 wax 一样，但不推荐这么做，因为： JSPatch 和 wax 一样都是通过 Objective-C Runtime 的接口通过字符串反射找到对应的类和方法进行调用，这中间的字符串处理会损耗一定的性能，另外两种语言间的类型转换也有性能损耗，若用来做一个完整的业务模块，大量的频繁来回互调，可能有性能问题。 开发过程中需要用 OC 的思维写 JS/Lua，丧失了脚本语言自己的特性。 JSPatch 和 wax 都没有 IDE 支持，开发效率低。 若想动态为 APP 添加模块，目前 React Native 给出了很好的方案，解决了上述三个问题： JS/OC 不会频繁通信，会在事件触发时批量传递，提高效率。（详见 React Native 通信机制详解） 开发过程无需考虑 OC 的感受，遵从 React 框架的思想进行纯 JS 开发就行，剩下的事情 React Native 帮你处理好了。 React Native 连 IDE 都准备好了。 所以动态添加业务模块目前还是推荐尝试 React Native，但 React Native 并不会提供原生 OC 接口的反射调用和方法替换，无法做到修改原生代码，JSPatch 以小巧的引擎补足这个缺口，配合 React Native 用统一的 JS 语言让一个原生 APP 时刻处于可扩展可修改的状态。 目前 JSPatch 处于开发阶段，稳定性和功能还存在一些问题。 Reference to:http://www.cocoachina.com/ios/20150709/12468.html]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>JSPatch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C isa 指针 与 runtime 机制]]></title>
    <url>%2FProgramming%2Fobjective-c-isa-pointer-and-runtime%2F</url>
    <content type="text"><![CDATA[isa指针要认识什么是 isa 指针，我们得先明确一点： 在 Objective-C 中，任何类的定义都是对象。类和类的实例（对象）没有任何本质上的区别。任何对象都有 isa 指针。 那么什么是类呢？在 xcode 中用快捷键 Shift＋Cmd＋O 打开文件 objc.h 能看到类的定义：123456789101112131415#if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id;#endif/// An opaque type that represents a method selector.typedef struct objc_selector *SEL; 可以看出: Class 是一个 objc_class 结构类型的指针, id是一个 objc_object 结构类型的指针. 我们再来看看 objc_class 的定义 (runtime.h 中)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#if !OBJC_TYPES_DEFINED/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;/// An opaque type that represents an instance variable.typedef struct objc_ivar *Ivar;/// An opaque type that represents a category.typedef struct objc_category *Category;/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t;struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */#endif#ifdef __OBJC__@class Protocol;#elsetypedef struct objc_object Protocol;#endif/// Defines a methodstruct objc_method_description &#123; SEL name; /**&lt; The name of the method */ char *types; /**&lt; The types of the method arguments */&#125;;/// Defines a property attributetypedef struct &#123; const char *name; /**&lt; The name of the attribute */ const char *value; /**&lt; The value of the attribute (usually empty) */&#125; objc_property_attribute_t; 各个参数的意思： isa：是一个 Class 类型的指针. 每个实例对象有个 isa 的指针, 指向对象的类，而 Class 里也有个 isa 的指针, 指向 meteClass(元类)。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。同时注意的是：元类（meteClass）也是类，它也是对象。 元类也有 isa 指针,它的 isa 指针最终指向的是一个根元类(root meteClass).根元类的 isa 指针指向本身，这样形成了一个封闭的内循环。 super_class：父类，如果该类已经是最顶层的根类,那么它为 NULL。version：类的版本信息，默认为0。info：供运行期使用的一些位标识。instance_size：该类的实例变量大小。ivars：成员变量的数组。 各个类实例变量的继承关系： 每一个对象本质上都是一个类的实例。其中类定义了成员变量和成员方法的列表。对象通过对象的 isa 指针指向类。 每一个类本质上都是一个对象，类其实是元类（meteClass）的实例。元类定义了类方法的列表。类通过类的 isa 指针指向元类。 所有的元类最终继承一个根元类，根元类 isa 指针指向本身，形成一个封闭的内循环。 runtime 机制 runtime：指一个程序在运行（或者在被执行）的状态。也就是说，当你打开一个程序使它在电脑上运行的时候，那个程序就是处于运行时刻。在一些编程语言中，把某些可以重用的程序或者实例打包或者重建成为“运行库”。这些实例可以在它们运行的时候被连接或者被任何程序调用。 objective-c 中 runtime：是一套比较底层的纯 C 语言 API，属于 1 个 C 语言库，包含了很多底层的 C 语言 API。在我们平时编写的 OC 代码中，程序运行过程时，其实最终都是转成了 runtime 的 C 语言代码。 runtime 的应用： 动态创建一个类(比如 KVO 的底层实现) 动态地为某个类添加属性\方法, 修改属性值\方法 遍历一个类的所有成员变量(属性)\所有方法 实质上，以上的是通过相关方法来获取对象或者类的 isa 指针来实现的。 runtime 相关函数 增加 增加函数:class_addMethod 增加实例变量:class_addIvar 增加属性:@dynamic标签，或者class_addMethod，因为属性其实就是由 getter 和 setter 函数组成 增加 Protocol:class_addProtocol 获取 获取函数列表及每个函数的信息(函数指针、函数名等等):class_getClassMethod method_getName ... 获取属性列表及每个属性的信息:class_copyPropertyList property_getName 获取类本身的信息,如类名等：class_getName class_getInstanceSize 获取变量列表及变量信息：class_copyIvarList 获取变量的值 替换 将实例替换成另一个类：object_setClass 替换类方法的定义：class_replaceMethod 其他常用方法 交换两个方法的实现：method_exchangeImplementations. 设置一个方法的实现：method_setImplementation. runtime 用法 Reference To:http://www.jianshu.com/p/41735c66dccb]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 3 特性]]></title>
    <url>%2FProgramming%2Fswift-3-feature%2F</url>
    <content type="text"><![CDATA[Swift 各版本发展历程Swift 1 确立了语言的基线: 安全, 快速, 现代.Swift 2 展现了 Swift 应该是什么, 未来怎么走: 面向协议的编程, 开源.Swift 3 更多的是清扫和规范: 新的 API 设计简洁干净, 减少了歧义, 溢出了很多 C 风格语法使代码风格更加一致, 可读性更高. 从语言使用的角度上, 大致做了如下修改或新特性: API 的重命名和规范 避免歧义方法名中应该包含所有需要的单词以减少阅读时的困惑. 删除协议名字的 ‘Type’ 后缀 删除冗余的词 根据 Side Effect 来决定命名 方法名单词词性.e.g. array.sort() 对 array 进行排序, array.sorted() 返回一个新的 array方法名长度缩短.e.g. stringByAppendingString(aString: String) 改为 appending(_ aString: String) 引用 Objective-C 和 C 代码很多 Objective-C Constants 在 Swift 中成了 Enum (Swift 3 中 Enum 小写字母开头). C 的 APIs 原来是全局的方法和变量, 现在引入为变量使用. e.g. CGContext123context.lineWidth = 1 context.strokeColor = CGColor(gray: 0.5, alpha: 1.0) context.drawPath(mode: .Stroke) dispatch 的 APIs 也更加 Swifty123456789101112let queue = DispatchQueue(label: "com.example.imagetransform") queue.async &#123; let smallImage = image.resize(to: rect) DispatchQueue.main.async &#123; imageView.image = smallImage &#125;&#125;let delay = DispatchTime.now() + .seconds(60) queue.after(when: delay) &#123; // ...&#125; 语法 C 风格的语法自增 ++ 和 自减 -- 运算符被移除for 循环 for (int i = 0; i &lt; array.count; i++) 也不再使用 函数* 函数参数中 `let` 的显示使用被移除 * 函数参数中 var 被移除 * inout 调整为类型修饰, 而不是参数名修饰. fouc double(input: inout Int) * 同 inout 类似, `@noescape` 和 `@autoclosure` 也转变为类型修饰. `fouc foo(f: @noescape () -&gt; ()) {}` * Curry 函数的声明语法被移除. `func foo(x: Int)(y: Int)` 类似语法应该用 `fouc foo(x: Int) -&gt; (y: Int) -&gt; Int` 这种语法替换 EnumEnum 所有成员都改为小写, 枚举中必须在成员前加上左前缀点123456789101112131415// 之前只是在枚举外使用需要加, 现在枚举内部对 self 进行 switch, 也一定要加, 确保代码的一致性enum Season &#123; case spring case summer case fall case winter var foo: String &#123; switch self &#123; case .spring: return ... case .summer: return ... ... &#125; &#125;&#125; 有关联值的 enum, 在 case 后可以声明多个成员1234567891011enum MyEnum &#123; case case1(Int, Float) case case2(Float, Int)&#125;switch value &#123; case let .case(x, 2), let .case2(2, x): print(x)case .case1, .case2: break&#125; 访问级别在 Swift 3 之前, 有三种访问级别: 公开 (public)内部 (internal)私有 (private) 默认的是 internal, 成员只能在 moudule 内可见. 如果要在 moudule 外使用, 应设置为 public. private 辨识改私有成员只能在其所在文件内使用 Swift 3 中多了一种访问级别 fileprivate, fileprivate 等同于之前的 private, 而 private 修改为之在其对应的作用域中可见. Where Generic 声明 在 Generic 声明中, where 语句被移到了最后1234567891011121314// Swift 3 之前, 原来的方法func anyCommonElements&lt;T : SequenceType, U : SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt;(lhs: T, _ rhs: U) -&gt; Bool &#123; ...&#125;// Swift 3 中, 正确语法应该是func anyCommonElements&lt;T : SequenceType, U : SequenceType&gt;(lhs: T, _ rhs: U) -&gt; Bool where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element &#123; ...&#125; 条件判断 where 在条件判断语句中被删掉, 改用逗号表示.12345// 原来的guard判断guard let x = opt1, y = opt2 where x == y else &#123;&#125;// Swift 3 中应该为guard let x = opt1, y = opt2, x == y else &#123;&#125; Implicitly Unwrapped Optional 原来隐式解析 Optional 类型…. Reference To：…API Design Guidelines]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[透传消息 与 推送消息]]></title>
    <url>%2FProgramming%2Fpassthrough-msg-and-push-msg%2F</url>
    <content type="text"><![CDATA[目前市场上的消息推送方式有两种：通知和透传。什么是透传？透传即是透明传送，即传送网络无论传输业务如何，只负责将需要传送的业务传送到目的节点，同时保证传输的质量即可，而不对传输的业务进行处理。透传消息，就是消息体格式及内容，对于传递的通道来说是不去过问的，通道只负责消息的传递，对消息不做任何处理，当客户端接收到透传消息后，由客户端自己来决定如何处理消息。正是因为透传消息可以自定义消息体，也可以自定义消息的展示方式及后续动作处理，所以弥补了通知栏消息的一些不足之处（通知栏消息是直接展示出来，相关的动作客户端无法捕获到）。 透传消息主要有如下特点： 后台处理，用户无感知。 前台展示，提醒用户。 展示的多样化。 整个透传消息的流程如下：根据个推提供的 API 接口或在个推开发者平台上推送透传消息，个推服务端接收到推送的消息后，不做任何处理，直接发送给目标用户。当客户端 SDK 接收到透传消息后，以广播方式发送给客户端，客户端在配置的第三方 BroadReceiver 里接收到透传消息后进行处理。 透传消息的消息体，可以根据不同的需求传递不同的参数或格式。如传递一个简单的字符串，或传递一个 Json 字符串，里面根据需求传递需要的字段。用户无感知的透传，如：更新相关信息，在主界面中相关栏位用红点标识进行弱提醒，推送一条命令用来检测用户是否有登录等。通知栏消息虽然方便的提醒用户，但也在一定程度上给用户带来了打扰，用户无感知的消息推送有时效果会更好。用户有感知的透传：把透传消息处理成通知栏展示出来，提醒用户方便点击查看相关信息（如个人帐单信息），直接打开应用或跳转到指定的应用界面中（根据透传消息的相关参数来判断跳转到哪一个指定的界面，相关参数传递要打开的界面的类名或 Intent 即可）等。对于开发者，处理成通知栏的相关事件也是可以捕获的，如通知栏的展示、点击等事件都可以进行捕获，以方便进行后续的操作。因透传消息可以自己处理成通知栏内容展示，所以通知栏的样式也可以根据需求来做对应的改变。在 Android 4.4 及以上的系统，通知栏可以是样式丰富的通知栏，放入图片和视频等；可以展示普通的通知，也可以展示多样化的通知。]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>message</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about GIT-LFS]]></title>
    <url>%2FTool%2Fabout-git-lfs%2F</url>
    <content type="text"><![CDATA[What作为开源的 Git 扩展，Git 大文件存储（Large File Storage，简称 LFS）的目标是更好地把“大型二进制文件，比如音频文件、数据集、图像和视频”集成到 Git 的工作流中。 Why众所周知，Git 在存储二进制文件时效率不高，因为：Git 默认会压缩并存储二进制文件的所有完整版本，如果二进制文件很多，这种做法显然不是最优。 By default git will compress and store all subsequent full versions of the binary assets, which is obviously not optimal if you have many. Git LFS 处理大型二进制文件的方式是用“文本指针”替换它们。这些文本指针实际上是包含二进制文件信息的文本文件。文本指针存储在 Git 中，而大文件本身通过 HTTPS 托管在 Git LFS 服务器上。 Git LFS approach to large binary files handling consists in replacing them with “text pointers,” i.e, text files containing information to identify the binary file. Text pointers are stored inside Git, while the large files themselves are hosted on a Git LFS server over HTTPS. 使用 LFS : 有效的处理大文件 当然，LFS 并不能像”变魔术一样”处理所有的大型数据：它需要记录并保存每一个变化。然而，这就把负担转移给了远程服务器 —— 允许本地仓库保持相对的精简。为了实现这个可能，LFS 耍了一个小把戏：它在本地仓库中并不保留所有的文件版本，而是仅根据需要提供检出版本中必需的文件。但这引发了一个有意思的问题：如果这些庞大的文件本身没有出现在你的本地仓库中…… 改用什么来代替呢? LFS 保存轻量级指针中有真实的文件数据。当你用一个这样的指针去迁出一个修订版时，LFS 会很轻易地找到源文件（不在他上面可能就在服务器上，特殊缓存）然后你下载就行了。因此，你最终只会得到你真正想要的文件，而不是一些你可能永远都不需要冗余数据。 Git LFS 命令 Git LFS 向 Git中添加了一条新命令 lfs，支持以下参数： config：显示 Git LFS 的配置。 init：初始化 Git LFS。 logs：显示 Git LFS 中的错误。 track：向 Git 仓库中添加一个大文件；允许指定文件扩展名。 untrack：从 Git LFS 中移除一个文件。 push：把当前监控的文件推送到 Git LFS 服务器。 status：显示产生改动的 Git LFS 对象的路径。 1234567config: display Git LFS configuration.init: initialized Git LFS.logs: show errors from git-lfs.track: add a large file to Git repo; it allows to specify a file extension.untrack: remove a file from Git LFS.push: push tracked files to Git LFS endpoint.status: Displays paths of modified Git LFS objects. How使用LFS追踪文件12345678// 没有特别说明的情况下，LFS 不会处理大文件问题，因此，我们必须明确告诉 LFS 该处理哪些文件。git lfs track &quot;design-resources/design.psd&quot; // 让我们回到“大 Photoshop 文件”的示例， 我们可以使用“lfs track”命令来告诉 LFS 处理“design.psd”文件. 乍一看，这条命令好像没生效，不过，你会看到项目根目录下新建了一个新文件 &quot;.gitattributes&quot; （如果已存在，将会被修改），&quot;.gitattributes&quot; 文件记录了我们用 LFS 追踪的所有的文件路径。cat .gitattributesdesign-resources/design.psd filter=lfs diff=lfs merge=lfs -textgit add .gitattributesgit add design-resources/design.psd // 棒棒哒！在这之后 LFS 会处理这个文件。我们接下来只要像往常那样把这个文件提交到仓库。值得注意的是，&quot;.gitattributes&quot; 文件也需要提交到仓库，操作和提交其他修改文件一样：git commit -m &quot;Add design file&quot;git push origin master 追踪文件路径1234// 添加单一文件如上所示就可以。但是，比如说，如果你想追踪项目里所有后缀名为 indd 的文件呢？放心，你不用手动的添加每个文件。LFS 允许你定义文件路径，就像忽略文件时的用法那样。举个例子，下面的命令会告诉 LFS 追踪所有的 InDesign 文件 — 已经存在的和以后添加的。git lfs track &quot;*.indd&quot;// 你也可以告诉 LFS 追踪整个文件夹里的所有内容git lfs track &quot;design-assets/*&quot; 追踪文件概述有时候，你可能想知道到底有哪些文件在被 LFS 追踪。你可以简单的看看.gitattributes文件。然而，它们不是真实的文件，而是包含一些规则和理论的文件：某些文件可能会漏掉，例如由于拼写错误或者过分严格的规则。 123// 想要查看你当前正在追踪的实际文件的列表，可以使用 git lfs ls-files 命令：git lfs ls-files194dcdb603 * design-resources/design.psd When记住 LFS 并没有改变 Git 本身的原理：被提交到仓库中的文件还会留在那儿。改变项目的提交历史很困难（也有风险）。这意味着你应该在文件没有提交到仓库前就让 LFS 进行追踪。不然，它就成了项目历史的一部分 - 令项目增大数 MB 或数 GB 的大小。初始化仓库时要选择配置要追踪的文件规则的完美时机（就跟配置忽略文件一样）。 参考Git Large File StorageGit LFS TutorialGit Large File Storage Promises to Extend Git to Large Binary FilesGit大文件存储将帮助Git处理大型二进制文件Getting Started with Git LFSGit LFS 入门指南]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kibibyte]]></title>
    <url>%2FOthers%2Fkibibyte%2F</url>
    <content type="text"><![CDATA[从前，kilobyte 既可以表示 1024bytes，也可以表示 1000bytes，需要依靠语境等附加条件来判断它的用法。 于是，我们就遇到了诸如“100GB(GigaBytes) 硬盘不是 100GB(GibiBytes)”等麻烦，当然 GB/GiB 并不是造成这些问题的唯一原因。 在有了上述标准后，传统的 kilo/mega/giga/tera/peta/exa/zeta/yotta 将只用于数量级。而全新的 kibi/mebi/gibi/tebi/pebi/exbi/zebi/yobi 来承担以二进制倍增的另一面： 国际单位 IEC名称 IEC单位 kilo k/K 1000^1=1000 kibi Ki 2^10=1024 mega M 1000^2=1000000 mebi Mi 2^20=1048576 giga G 1000^3 gibi Gi 2^30 tera T 1000^4 tebi Ti 2^40 peta P 1000^5 pebi Pi 2^50 exa E 1000^6 exbi Ei 2^60 zeta Z 1000^7 zebi Zi 2^70 yotta Y 1000^8 yobi Yi 2^80 科技类文章使用这种以避免混淆。 参考：Kibibyte二进制乘数词头]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>none</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Warning from APPLE]]></title>
    <url>%2FProgramming%2Fa-warning-from-apple%2F</url>
    <content type="text"><![CDATA[Dear Developer,Your app, extension, and/or linked framework appears to contain code designed explicitly with the capability to change your app’s behavior or functionality after App Review approval, which is not in compliance with section 3.3.2 of the Apple Developer Program License Agreement and App Store Review Guideline 2.5.2. This code, combined with a remote resource, can facilitate significant changes to your app’s behavior compared to when it was initially reviewed for the App Store. While you may not be using this functionality currently, it has the potential to load private frameworks, private methods, and enable future feature changes.This includes any code which passes arbitrary parameters to dynamic methods such as dlopen(), dlsym(), respondsToSelector:, performSelector:, method_exchangeImplementations(), and running remote scripts in order to change app behavior or call SPI, based on the contents of the downloaded script. Even if the remote resource is not intentionally malicious, it could easily be hijacked via a Man In The Middle (MiTM) attack, which can pose a serious security vulnerability to users of your app.Please perform an in-depth review of your app and remove any code, frameworks, or SDKs that fall in line with the functionality described above before submitting the next update for your app for review.Best regards,App Store Review]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>APPLE</tag>
        <tag>App Store</tag>
        <tag>review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非对称密钥 —— RSA 算法]]></title>
    <url>%2FProgramming%2Fasymmetric-cryptography-algorithm%2F</url>
    <content type="text"><![CDATA[简介RSA 算法是最流行的公钥密码算法，使用长度可以变化的密钥。RSA 是第一个既能用于数据加密也能用于数字签名的算法。 原理RSA 算法原理如下：1.随机选择两个大质数 p 和 q，p 不等于 q，计算 N=pq；2.选择一个大于 1 小于 N 的自然数 e，e 必须与 (p-1)(q-1) 互素。3.用公式计算出 d：d×e = 1 (mod (p-1)(q-1)) 。4.销毁 p 和 q。最终得到的 N 和 e 就是“公钥”，d 就是“私钥”，发送方使用 N 去加密数据，接收方只有使用 d 才能解开数据内容。 总结RSA 的安全性依赖于大数分解，小于 1024 位的 N 已经被证明是不安全的，而且由于 RSA 算法进行的都是大数计算，使得 RSA 最快的情况也比 DES 慢上倍，这是 RSA 最大的缺陷，因此通常只能用于加密少量数据或者加密密钥，但 RSA 仍然不失为一种高强度的算法。 案例分析虽然非对称加密很安全，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。为了解释这个过程，请看下面的例子：（1） Alice 需要在银行的网站做一笔交易，她的浏览器首先生成了一个随机数作为对称密钥。（2） Alice 的浏览器向银行的网站请求公钥。（3） 银行将公钥发送给 Alice。（4） Alice 的浏览器使用银行的公钥将自己的对称密钥加密。（5） Alice 的浏览器将加密后的对称密钥发送给银行。（6） 银行使用私钥解密得到 Alice 浏览器的对称密钥。（7） Alice 与银行可以使用对称密钥来对沟通的内容进行加密与解密了。 对称 VS 非对称 对称加密（Symmetric Cryptography）加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。 非对称加密（Asymmetric Cryptography）使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仮名 (かな, Kana)]]></title>
    <url>%2FLanguage%2Fkana%2F</url>
    <content type="text"><![CDATA[最近大家越来越热衷于玩农药，为避免自己业余时间也被农药吞噬，在著名网校某江上报了个五十音学习班。（由于账号注册时间太久了，竟然要当时留下的手机来验证安全性能，还好人工服务更新了现有手机号。）（更换手机号码确实将给日常生活带来极大不便，如果可以像其他地区一样更换运营商也可继续沿用之前的手机号就好了。） 平假名与片假名对照简表 a i u e o a あ い う え お ア イ ウ エ オ k か き く け こ カ キ ク ケ コ s さ し(shi) す(su) せ そ サ シ ス セ ソ t た ち(chi) つ(tsu) て と タ チ ツ テ ト n な に ぬ ね の ナ ニ ヌ ネ ノ h は{wa} ひ ふ(fu) へ{e} ほ ハ ヒ フ ヘ ホ m ま み む め も マ ミ ム メ モ y や ゆ よ ヤ ユ ヨ r ら り る れ ろ ラ リ ル レ ロ w わ を ワ ヲ 平假名的汉字来源 a i u e o a あ い う え お 安 以 宇 衣 於 k か き く け こ 加 畿(ji) 久 计 己 s さ し(shi) す(su) せ そ 左 之 寸 世 曾 t た ち(chi) つ(tsu) て と 太 知 川 天 止 n な に ぬ ね の 奈 仁 奴 祢(mi) 乃 h は{wa} ひ ふ(fu) へ{e} ほ 波 比 不 部 保 m ま み む め も 末 美 武 女 毛 y や ゆ よ 也 由 与 r ら り る れ ろ 良 利 留 礼 吕 w わ を 和 袁 片假名的汉字来源 a i u e o a ア イ ウ エ オ 阿 伊 宇 江 於 k カ キ ク ケ コ 加 畿 久 介 己 s サ シ ス セ ソ 散 之 须 世 曾 t タ チ ツ テ ト 多 千 川 天 止 n ナ ニ ヌ ネ ノ 奈 二 奴 祢 乃 h ハ ヒ フ ヘ ホ 八 比 不 部 保 m マ ミ ム メ モ 末 三 牟 女 毛 y ヤ ユ ヨ 也 由 与 r ラ リ ル レ ロ 良 利 流 礼 吕 w ワ ヲ 和 袁 还是截图/搜图比较方便 惨痛的教训平假名比较好记，但由于一开始没有重视片假名，导致之后学习过程中遇到片假名都要反应良久。╮(╯▽╰)╭所以打好基础是很重要滴！]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>日本語</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Instruments]]></title>
    <url>%2FProgramming%2Fxcode-performance-analyzer-instruments%2F</url>
    <content type="text"><![CDATA[功能 分析一个或多个进程的行为 记录一系列用户的动作并相应他们, 可靠地在线这些事件并收集多次运行的数据 创建自定义 DTrace instruments 来分析系统和应用程序的行为 保存用户界面记录和 instruments 的配置为模板, 并从 Xcode 访问 可进行的操作 追查代码中难以重现的问题 对程序进行性能分析 自动化测试代码 对程序进行压力测试 进行一般的系统级故障诊断 对代码如何工作更深入了解 运行环境Xcode 3.0 和 Mac OS X 10.5 及其以后 跟踪文档 (trace documents) template Blank Activity Monitor Allocations Cocoa Layout Core Animation Core Data Counters Energy Log File Activity Leaks Metal System Trace Network OpenGL ES Analysis System Trace System Usage Time Profiler Zombies 关键特性 (Trace document key features) Feature Description Instruments pane This pane holds the instruments you want to run. You can drag instruments into this pane or delete them. You can click the inspector button in an instrument to configure its data display and gathering parameters. Track pane The track pane displays a graphical summary of the data returned by the current instruments. Each instrument has its own “track,” which provides a chart of the data collected by that instrument. The information in this pane is read-only. You do use this pane to select specific data points you want to examine more closely, however. Detail pane The Detail pane shows the details of the data collected by each instrument. Typically, this pane displays the explicit set of “events” that were gathered and used to create the graphical view in the track pane. If the current instrument allows you to customize the way detailed data is displayed, those options are also listed in this pane. Extended Detail pane The Extended Detail pane shows even more detailed information about the item currently selected in the Detail pane. Most commonly, this pane displays the complete stack trace, timestamp, and other instrument-specific data gathered for the given event. Navigation bar The navigation bar shows you where you are and how you got there. It includes two menus—the active instrument menu and the detail view menu. You can click entries in the navigation bar to select the active instrument and the level and type of information in the detail view.]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C 异常处理的 signal]]></title>
    <url>%2FProgramming%2Fobjective-c-crash-signal%2F</url>
    <content type="text"><![CDATA[Crash Callstack 属性 说明 0x8badf00d 在启动、终⽌止应⽤用或响应系统事件花费过⻓长时间, 意为“ate bad food” 0xdeadfa11 ⽤用户强制退出, 意为“dead fall”。(系统⽆无响应时, ⽤用户按电源开关和 HOME) 0xbaaaaaad ⽤用户按住 Home 键和⾳音量键, 获取当前内存状态, 不代表崩溃 0xbad22222 VoIP 应⽤用因为恢复得太频繁导致 crash 0xc00010ff 因为太烫了被干掉, 意为“cool off” 0xdead10cc 因为在后台时仍然占据系统资源(⽐比如通讯录)被干掉, 意为“dead lock” 异常signal SIGHUP本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一 session 内的各个作业, 这时它们与控制终端不再关联。登录 Linux 时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个 Session。当用户退出 Linux 登录时，前台进程组和后台有对终端输出的进程将会收到 SIGHUP 信号。这个信号的默认操作为终止进程，因此前台进 程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如 wget 能捕获 SIGHUP 信号，并忽略它，这样就算退出了 Linux 登录， wget 也能继续下载。此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。 SIGINT程序终止(interrupt)信号, 在用户键入INTR字符(通常是 Ctrl-C)时发出，用于通知前台进程组终止进程。 SIGQUIT和 SIGINT 类似, 但由 QUIT 字符(通常是 Ctrl-)来控制. 进程在因收到 SIGQUIT 退出时会产生 core 文件, 在这个意义上类似于一个程序错误信号。 SIGILL执行了非法指令。通常是因为可执行文件本身出现错误, 或者试图执行数据段，堆栈溢出时也有可能产生这个信号。 SIGTRAP由断点指令或其它 trap 指令产生。由 debugger 使用。 SIGABRT调用 abort 函数生成的信号。 SIGBUS非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是 4 的倍数。它与 SIGSEGV 的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。 SIGFPE在发生致命的算术运算错误时发出。不仅包括浮点运算错误, 还包括溢出及除数为 0 等其它所有的算术的错误。 SIGKILL用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。 SIGUSR1留给用户使用 SIGSEGV试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据。 SIGUSR2留给用户使用 SIGPIPE管道破裂。这个信号通常在进程间通信产生，比如采用 FIFO (管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到 SIGPIPE 信号。此外用 Socket 通信的两个进程，写进程在写 Socket 的时候，读进程已经终止。 SIGALRM时钟定时信号, 计算的是实际的时间或时钟时间. alarm 函数使用该信号. SIGTERM程序结束(terminate)信号, 与 SIGKILL 不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell 命令 kill 缺省产生这个信号。如果进程终止不了，我们才会尝试 SIGKILL。 SIGCHLD子进程结束时, 父进程会收到这个信号。如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情 况我们应该避免(父进程或者忽略 SIGCHILD 信号，或者捕捉它，或者 wait 它派生的子进程，或者父进程先终止，这时子进程的终止自动由 init 进程 来接管)。 SIGCONT让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个 handler 来让程序在由 stopped 状态变为继续执行时完成特定的工作. 例如, 重新显示提示符 SIGSTOP停止(stopped)进程的执行. 注意它和 terminate 以及 interrupt 的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略. SIGTSTP停止进程的运行, 但该信号可以被处理和忽略. 用户键入 SUSP 字符时(通常是 Ctrl-Z)发出这个信号 SIGTTIN当后台作业要从用户终端读数据时, 该作业中的所有进程会收到 SIGTTIN 信号. 缺省时这些进程会停止执行. SIGTTOU类似于 SIGTTIN, 但在写终端(或修改终端模式)时收到. SIGURG有”紧急”数据或 out-of-band 数据到达 socket 时产生. SIGXCPU超过CPU时间资源限制. 这个限制可以由 getrlimit/setrlimit 来读取/改变。 SIGXFSZ当进程企图扩大文件以至于超过文件大小资源限制。 SIGVTALRM虚拟时钟信号. 类似于 SIGALRM, 但是计算的是该进程占用的 CPU 时间. SIGPROF类似于 SIGALRM/SIGVTALRM, 但包括该进程用的 CPU 时间以及系统调用的时间. SIGWINCH窗口大小改变时发出. SIGIO文件描述符准备就绪, 可以开始进行输入/输出操作. SIGPWRPower failure SIGSYS非法的系统调用。 signal归纳 在以上列出的信号中，程序不可捕获、阻塞或忽略的信号有：SIGKILL, SIGSTOP 不能恢复至默认动作的信号有：SIGILL, SIGTRAP 默认会导致进程流产的信号有：SIGABRT, SIGBUS, SIGFPE, SIGILL, SIGIOT, SIGQUIT, SIGSEGV, SIGTRAP, SIGXCPU, SIGXFSZ 默认会导致进程退出的信号有:SIGALRM, SIGHUP, SIGINT, SIGKILL, SIGPIPE, SIGPOLL, SIGPROF, SIGSYS, SIGTERM, SIGUSR1, SIGUSR2, SIGVTALRM 默认会导致进程停止的信号有：SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU 默认进程忽略的信号有：SIGCHLD, SIGPWR, SIGURG, SIGWINCH 此外，SIGIO在 SVR4 是退出，在 4.3 BSD 中是忽略；SIGCONT在进程挂起时是继续，否则是忽略，不能被阻塞。]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[some words]]></title>
    <url>%2FLanguage%2Fshanbay-english-words-memo%2F</url>
    <content type="text"><![CDATA[新年第一天，要好好学习，再次拾起几经中断的某贝单词，竟然没被踢出小组，整个小组都咸鱼啦。部分同学仍然很坚持。记录下遇到的一些单词或句子 on women’s rights the disease to please (女性)取悦于人的社会弊病(disease 除疾病外, 还可以抽象表示在社会某一群体的弊病, 恶习) sexual abuse 性虐待 (abuse 两大意思: 虐待和滥用) sexual advance 性骚扰 (advance 名词意思除了前进/进步外, 还有挑逗/勾引的意思) close the gender pay gap 缩短男女薪酬差异 It was just the way things were. 过去我认为(同工不同酬)是自然而然无可厚非的。 righteous anger 义愤 take a toll 产生负面影响 造成损失 one’s crowning achievement 某人的最高(显著)成就heavily bureaucratic rules 官场的繁文缛节, 繁杂的官僚制度bust bureaucracy roadblocks 打破官僚主义的路障under the auspices of 在…的主办之下sequence the genome 基因测序 英语中有许多表示否定的前缀：主要有 dis- in- im- il- ir- un- mis- non- dis- de- anti- counter- 等；dis- 主要加在名词、形容词，动词之前，dis- 为否定前缀的词有：disadvantage 缺点、dishonorable 不光彩的、disagree 不同意等；in- 常加在形容词，名词之前，如 incorrect 不正确的、inability 无能 无力、inaccurate 不准确的等；im- 加在字母 m,b,p 之前，这样的词有 impossible 不顺能的、impolite 不礼貌的、impudence 厚颜无耻；il- 主要加在以 l 开头的单词的前边，比如：illegal 非法的、illiterate 文盲的 没有文化的、illogical 不合逻辑的；ir- 放在以 r 开头的英语单词前面，比如：irregular 不稳定的、irresistable 不可抵抗的、irresolvable 不能分解的 不能解决的；un- 主要放于名词，形容词，副词前面，常见的例子有 unfinished 未完成的、undoubted 无疑的、unemployment 失业；non- 加在形容词、名词前，这样以 non- 为否定前缀的词有 non-existence 不存在、non-essential 不主要的、non-electrical 非电的；而 mis- 加在动词、名词前，例词 misunderstand 误解、misjudge 误判、misleading 误导、misfortune 不幸；dis- 加在动词之前，例词有 disappear 消失、disarm 解除武装、disconnect 失去联系；de- 加在名词、形容词前，常见的例词有 demobilize 遣散 使…复员、decolor 脱色 漂白；anti- 加在名词、形容词前边。最常见的是 anti-Japanese 抗 RI 战争、anti-social 厌恶社会的 反社—会的、antidite 解毒的药；最后一个 counter- 加在名词、动词前，例如：counterattack 反攻 反击、counteract 抵抗阻碍、counterrevolution 反革—–命。 Fear evacuated their minds of reasons.恐惧使他们失去了理智 Large classes dilute the quality of education that children receive.大班上课会降低孩子所受教育的质量。 first-ever 史无前例的whatsoever endorse – [usually passive] 在(驾驶执照上)记录违章事项 You risk having your licence endorsed. A high-fat diet correlates with a greater risk of heart disease. RTFM – Read The Fucking Manual (RTBM – Read The Bloody Manual, RTFS – Read The Fucking Source, RTFA – Read The Fucking Article)GIYF – Google Is Your FriendSTFW – Search The Fucking Web (UTFG – Use the Fucking Google)JFGI – Just Fucking Google It RTFMJFGI “The Buck Stops Here” The cuckoo is the herald of the spring. 杜鹃报春。 cuckoo 布谷鸟、杜鹃 herald vt.n. 使者，预兆The crocus is a herald of spring. 报春花]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode 中查看方法的调用者列表 (Method callers in Xcode)]]></title>
    <url>%2FTool%2Fmethod-callers-in-xcode%2F</url>
    <content type="text"><![CDATA[一直喜欢 Shift + Control + Command + H 双手查看，但有时拿笔时比较尴尬。 （一）直接查看类和方法的继承及调用列表 在代码中点击（或选中）方法名； 点击代码编辑区域左上角的“方块”图标，会弹出一个弹出窗口； 在弹出窗口中选择 Callers，右侧就有列出所有调用此方法的位置；选择 Callees 则会显示此方法调用的所有其他方法。 或者 Command + Enter 到辅助编辑器 -&gt; Mannal 中点选 “Callers/Callees” （二）双指单击方法名（相当于以往 Windows 下的右击鼠标效果）弹出 pop-up menu -&gt; Find Call Hierachy （三）点击方法名 -&gt; Shift + Control + Command + H（需双手操作） （四）Command + 3 to Show the Find Navigator -&gt; find -&gt; Call Hierachy -&gt; 输入方法名 -&gt; Enter （太繁杂） Reference to:In Xcode, how can I find all caller functions of a specific function?]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>shortcut</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebAPP 与原生 APP 的交互设计区别]]></title>
    <url>%2FProgramming%2Finteraction-web-app-and-native-app%2F</url>
    <content type="text"><![CDATA[原文地址：http://www.woshipm.com/ucd/132869.html 从使用场景上，WAP 用户面临比 APP 用户更严峻的问题：1、页面跳转更加费力，不稳定感更强思考点：如何减少跳转（扁平结构、页面布局技巧），增加数据及展示的流畅流程及稳定性（技术）2、更小的页面空间（由于浏览器的导航本身占用一部分屏幕空间），更大的信息记忆负担思考点：排版更清晰、信息更简练 （可在 APP 基础上去掉一些丰富、复杂的视觉表现）3、导航不明显，原有底部导航消失，有效的导航遇到挑战思考点：如何有效的提供导航？有哪些形式？4、交互动态效果收到限制，影响一些页面场景、逻辑的理解。思考点：比如登录注册流程的弹出、完成及异常退出，做好文字提示。 针对以上困境，解决方法总结如下。 首先，从 APP 到 WAP 版，在产品上，最明显且核心的：1、精简功能，只将核心的任务实现，非核心的枝节可考虑删减。2、做好新的 WAP 导航.3、补充从 WAP 站对 下载 APP 的引导。 WAP导航怎样设计？一、常见的几种 WAP 导航样式1.1 顶部底部导航的设计： 1.2 导航快捷键设计：美团：顶部栏固定位置淘宝：悬浮圆圈–可展开的按钮优酷：非首屏时页面右侧悬浮 二、有效的导航设计1、基本的快捷导航中包括 返回常用页面（如 首页 我的 等）的快捷方式2、出现深层架构时 及时补充返回重要层级页面的快捷方式3、情境式导航，方便用户快捷跳转到他想去的页面，如购买结束时提供查看订单详情的按钮。ps：WAP 页更加需要画页面跳转的流程图，摸清各个页面的入口，尤其是页面返回的流程；有些简化的返回按钮，可以特殊注明返回到的页面 怎样引导用户下载APP?一、在哪里出现引导？一般 首页、核心任务的页面（如 电商WAP的商品详情页 、视频 WAP 的视频观看页） 二、引导下载 APP 有哪些形式？1、页面顶部放置下载条2、页面底部悬浮层引导3、融合在页面首屏中4、下载按钮形式5、底部 foot 里含： 客户端下载入口 其次，在设计 WAP 版上，有以下小技巧可以参考： 从页面布局上减少跳转：使用交互技巧隐藏文字（eg 腾讯视频） 取消 float 浮层，增大展示空间（eg：大众点评）取消 float 浮层，同时在详情尾部再次加上 “购买”按钮 页面中对图片进行缩小（因情况而异）的处理、精简一些标签导航的视觉展现 技术上注意点：1）各手机浏览器的兼容测试2）底层服务的调取（能调取，但只有当其是核心功能时才保留 eg：新浪、美团等皆去掉了头像上传功能）3）注意离线数据存储，减少数据请求频率。4）考虑保存用户的哪些数据：设置、个人数据、阅读锚点、跳出页面等。5）避免动效与浏览器的交互冲突6）按顺序 异步加载 eg： 腾讯视频 扯一下虽然 WAP 页目前处于比较尴尬的地位，我们是由于APP中一些页面需要分享出去才开启制作 WAP 版。但是不得不承认，基于 WAP 的轻 APP 更新迭代起来更方便]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>native</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Native or HTML5?]]></title>
    <url>%2FProgramming%2Fnative-app-or-html5-app%2F</url>
    <content type="text"><![CDATA[优劣比较 Native APP指的是原生程序，一般依托于操作系统，有很强的交互，是一个完整的 APP ，可拓展性强。需要用户下载安装使用。 优点：打造完美的用户体验、性能稳定、操作速度快，上手流畅、访问本地资源（通讯录，相册）、设计出色的动效，转场、拥有系统级别的贴心通知或提醒、用户留存率高。 缺点：开发成本高（不同平台有不同的开发语言和界面适配）、维护成本高（例如一款 APP 已更新至 V5 版本，但仍有用户在使用 V2， V3， V4 版本，需要更多的开发人员维护之前的版本）、更新缓慢，根据不同平台，提交–审核–上线 等等不同的流程，需要经过的流程较复杂。 Web APP指采用 Html5 语言写出的 APP，不需要下载安装。类似于现在所说的轻应用。生存在浏览器中的应用，基本上可以说是触屏版的网页应用。 优点：开发成本低、更新快、更新无需通知用户，不需要手动升级、能够跨多个平台和终端。 缺点：临时性的入口、无法获取系统级别的通知，提醒，动效等等、用户留存率低、设计受限制诸多、体验较差。 Html5 通常拿来做推广辅助，做个游戏，有个产品页面之类的宣传主要还是Html5 渲染不过关，Network Access已经不是问题了 12345678910其实h5和native各有优劣，首先是h5的优势：1. 用h5做的页面迭代速度快，每次就更新服务器的文件用户那头就更新了，不用好像native那样各种提交app store审核，审核不过打回来然后还继续审，万一不小心有bug带出去了又要重新更新一个版本。这是h5的一个巨大的优势——迭代迅速2. h5现在已经能做越来越多的事，从地理位置获取到传感器获取到陀螺仪，h5的能力已经越来越大，并且相信会变得更大，这让开发者的门槛大大降低，更多的前端可以直接用js就能做出强大的东西——潜力3. 跨平台。现在要做一个原生的app，至少要一批人做ios一批人做android，说不定做大点，windows phone又要找一批人搞，成本对小团队来说可相当不小，而h5，基本搞定一个就全部通用了。跨平台同样是h5的一个大优势——成本低优势说完了劣势来了：1. 说实话h5的性能真的差得可以，处女座表示实在很难接受，之前算是h5负责了比较久，想方设法开硬件加速，减少节点减少请求乱七八糟，是相对效率高了，但是离原生还有很大的距离，这个也不多说了，性能是硬伤——性能性能还是性能2. 很多h5的页面喜欢模仿原生的来做，往往原生一两句代码就能搞定的东西，用h5做要写一堆css而且还模仿得不像，人家“啪！”那个选择框就弹出来了但在h5里面卡了2下再出来，这就是差别。而且用h5的话控件难以根据系统更改风格，例如ios6,ios7的选择框是不同的，原生的话自动适配但是h5倒没那么好搞了——界面难以做到和原生一样和手机ui统一3. h5的bug真的呵呵呵呵呵呵，好不容易从ie6怪圈逃出来了又遇到了各种各样的android，甚至ios也会抽风。你说ie6的bug嘛还算有迹可循，百度也有很多沉淀，移动终端的我遇到好多bug根本百度不了，测试那里一堆手机一个个测总有各种各样奇怪的问题，胜在有万能的google和stackoverflow——bugs 如何判断 断网情况显示404或则错误页面的是html页面。 页面布局(Android, 开发者选项中显示布局边界) 复制文章的提示 加载方式如果在打开新页面导航栏下面有一条加载的线的话，这个页面就是H5页面 导航栏是否会有关闭的操作如果APP顶部导航栏当中出现了关闭按钮或者有关闭的图标，那么当前的页面肯定的H5，原生的不会出现（除非设计开发者故意弄的）.美团的、大众点评的APp、微信APP当加载h5过多的时候，左上角会出现关闭2字。 判断页面 下拉刷新的时候（前提是要有下拉刷新的功能）如果界面没有明显刷新现象的是原生的，如果有明显刷新现象（比如闪一下）的是H5页面（ios和android）。 下拉页面的时候显示网址提供方的一定是H5 常用的判断方法： 体验一般加载很慢且滑动很不流畅，切换时预加载和模拟动画–css3动画非常的消耗性能 剪切板事件长按文字部分，进入选中之后，把选中的光标上下拖动。html 写出来的页面可以把很多图片、文字等一起选进去，原生的一般仅限于文字区域。 抓包 12大家大谈H5APP时都是快速开发、低成本、多平台等等，但是它和很多APP开发方式相比有一个不同之处 —— `图文混合的排版`。正是这些复杂多变的CSS样式消耗了性能，但是它带来了排版的多样性，能够细致到每一个字宽行高和风格的像素级处理，才是H5的优异之处。很多人都说纯H5一次编写就能编译Android/iOS两种不同的APP，大大降低了成本。实际上这个观点本身就是值得怀疑的，如果你写过这类APP就能明白，它们既不省事，又存在很多BUG，调试时尤其繁琐。举一个很简单的例子，Android和iOS在返回上一页的处理方式上就有明显的区别，iOS的顶部bar在全屏下怎样处理，Android机器出现smart bar怎样处理页面的布局，调用底层硬件时怎样区分不同的场景等等，你需要写一个又一个机型和系统的判断，然后分别在Android和iOS下调试，最后你却发现这并没有卵用，累的要死却什么没学到，只有一堆不知道什么时候会过时的经验。 ThanksTo:]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Core Image 的简单使用 Part1 -- 图片滤镜 (以CIPhotoEffect..为例)]]></title>
    <url>%2FProgramming%2Fcoreimage-usage-part1-ciphotoeffect%2F</url>
    <content type="text"><![CDATA[Core Image 概述 Core Image is an image processing and analysis technology designed to provide near real-time processing for still and video images. It operates on image data types from the Core Graphics, Core Video, and Image I/O frameworks, using either a GPU or CPU rendering path. Core Image hides the details of low-level graphics processing by providing an easy-to-use application programming interface (API). You don’t need to know the details of OpenGL or OpenGL ES to leverage the power of the GPU, nor do you need to know anything about Grand Central Dispatch (GCD) to get the benefit of multicore processing. Core Image handles the details for you.1 CoreImage 是 iOS5 新加入的一个图像处理框架, 提供了强大高效的图像处理功能, 用来对基于像素的图像进行操作与分析.内置了很多强大的滤镜 (Filter), 这些 Filter 提供了各种各样的效果, 并且还可以通过滤镜链将各种效果的 Filter 叠加起来形成强大的自定义效果. Core Image 架构 2Core Image 有一个插件架构, 这意味着它允许用户编写自定义的滤镜并与系统提供的滤镜集成来扩展其功能. 此处不会用到 Core Image 的可扩展性, 提到它只是因为它影响到了框架的 API. Core Image 是用来最大化利用其所运行之上的硬件的. 每个滤镜实际上的实现, 即内核, 是由一个 GLSL (即 OpenGL 的着色语言) 的子集来书写的. 当多个滤镜连接成一个滤镜图表, Core Image 便把内核串在一起来构建一个可在 GPU 上运行的高效程序. 只要有可能, Core Image 都会把工作延迟. 通常情况下, 直到滤镜图表的最后一个滤镜的输出被请求之前都不会发生分配或处理. 为了完成工作, Core Image 需要一个称为上下文 (context) 的对象. 这个上下文是框架真正工作的地方, 它需要分配必要的内存, 并编译和运行滤镜内核来执行图像处理. 建立一个上下文是非常耗费性能的的, 所以要尽可能考虑到重用. 图片滤镜 (以CIPhotoEffect..为例)思路: originalUIImage -&gt; inputCIImage -&gt; (CIFilter) -&gt; outputCIImage -&gt; (CIContext) -&gt; CGImage -&gt; UIImage 三个主要对象: CIImage – 保存图像数据. 它可以从 UIImage, 图像文件, 或像素数据中构造. CIFilter – 包含的字典对各种滤镜定义了各自的属性. 滤镜有很多种，比如裁剪/色彩/模糊/像素等. 由于CoreImage的插件结构, 大多数滤镜属性并不是直接设置的, 而是通过键值编码(KVC)设置 CIContext – 图像处理都是在 CIContext 中完成的.为了完成工作, CoreImage需要一个称为上下文(context)的对象. 这个上下文是框架真正工作的地方, 它需要分配必要的内存, 并编译和运行滤镜内核来执行图像处理. 创建一个上下文(context)是非常耗性能的, 应重复使用. 123456789101112131415161718192021222324/// 传入滤镜名称(e.g. "CIPhotoEffectFade"), 输出处理后的图片- (UIImage *)outputImageWithFilterName:(NSString *)filterName &#123; // 1. // 将UIImage转换成CIImage CIImage *ciImage = [[CIImage alloc] initWithImage:self.originalImage]; // 创建滤镜 self.filter = [CIFilter filterWithName:filterName keysAndValues:kCIInputImageKey, ciImage, nil]; // 2. // 渲染并输出CIImage CIImage *outputImage = [self.filter outputImage]; // 3. // 获取绘制上下文 self.context = [CIContext contextWithOptions:nil]; // 创建CGImage CGImageRef cgImage = [self.context createCGImage:outputImage fromRect:[outputImage extent]]; // 获取图片 (不要直接`imageWithCIImage:`, CIContext重复, 性能) UIImage *image = [UIImage imageWithCGImage:cgImage]; // 释放CGImage CGImageRelease(cgImage); return image;&#125; CoreImage 提供的滤镜很多, 不便记忆. 可通过打印或po filter.attributes方式查看相应信息.1234567891011// 打印滤镜名称// `kCICategoryBuiltIn`内置; `kCICategoryColorEffect`色彩- (void)showFilters &#123; NSArray *filterNames = [CIFilter filterNamesInCategory:kCICategoryColorEffect]; for (NSString *filterName in filterNames) &#123; NSLog(@"%@", filterName); // CIFilter *filter = [CIFilter filterWithName:filterName]; // NSDictionary *attributes = filter.attributes; // NSLog(@"%@", attributes); // 查看属性 &#125;&#125; 123456789101112131415161718// 自动调整样式- (UIImage *)photoEffectAutoAdjust &#123; CIImage *ciImage = [[CIImage alloc] initWithImage:self.filterlessImage]; NSArray *filters = [ciImage autoAdjustmentFiltersWithOptions:nil]; CIImage *outputImage; for (CIFilter *filter in filters) &#123; [filter setValue:ciImage forKey:kCIInputImageKey]; [filter setDefaults]; outputImage = filter.outputImage; &#125; self.context = [CIContext contextWithOptions:nil]; CGImageRef cgImage = [self.context createCGImage:outputImage fromRect:[outputImage extent]]; UIImage *image = [UIImage imageWithCGImage:cgImage]; CGImageRelease(cgImage); return image;&#125; 效果图如下:original 原图 photoEffect 效果图 对应滤镜 AutoAdjust 自动 Instant 怀旧 Process 冲印 Chrome 铬黄 Mono 单色 Tonal 色调 Fade 褪色 Noir 黑白 Transfer 岁月 Prefers: 一直在用这个: developer.xamarin.com/api/type/CoreImage, 查看起来比较方便, 除了Core Image还有很多其它框架. ObjC 中国 - 期刊, 讲得都很精当, @onevcat大神等组建; 或者直接去objc.io, 不需搭梯子的哦. Core Image Reference Collection 和 Core Image Programming Guide 是Core Image的官方文档集. Core Image Filter Reference 包含了Core Image所提供图像滤镜的完整列表以及用法示例.]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Core Image</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom shortcut]]></title>
    <url>%2FTool%2Fatom-shortcut%2F</url>
    <content type="text"><![CDATA[找了好久了，先收藏起来背一背，提升效率好利器 文件切换ctrl-shift-s 保存所有打开的文件cmd-shift-o 打开目录cmd-\ 显示或隐藏目录树ctrl-0 焦点移到目录树目录树下，使用 a，m，delete 来增加，修改和删除cmd-t或cmd-p 查找文件cmd-b 在打开的文件之间切换cmd-shift-b 只搜索从上次 git commit 后修改或者新增的文件 导航// 等价于上下左右ctrl-p 前一行ctrl-n 后一行ctrl-f 前一个字符ctrl-b 后一个字符 alt-B, alt-left 移动到单词开始alt-F, alt-right 移动到单词末尾 cmd-right, ctrl-E 移动到一行结束cmd-left, ctrl-A 移动到一行开始 cmd-up 移动到文件开始cmd-down 移动到文件结束 ctrl-g 移动到指定行 row:column 处 cmd-r 在方法之间跳转 目录树操作cmd-\ 或者 cmd-k cmd-b 显示(隐藏)目录树ctrl-0 焦点切换到目录树（再按一次或者Esc退出目录树）a 添加文件d 将当前文件另存为（duplicate）i 显示（隐藏）版本控制忽略的文件alt-right 和 alt-left 展开（隐藏）所有目录ctrl-al-] 和 ctrl-al-[ 同上ctrl-[ 和 ctrl-] 展开（隐藏）当前目录ctrl-f 和 ctrl-b 同上cmd-k h 或者 cmd-k left 在左半视图中打开文件cmd-k j 或者 cmd-k down 在下半视图中打开文件cmd-k k 或者 cmd-k up 在上半视图中打开文件cmd-k l 或者 cmd-k right 在右半视图中打开文件ctrl-shift-C 复制当前文件绝对路径 书签cmd-F2 在本行增加书签F2 跳到当前文件的下一条书签shift-F2 跳到当前文件的上一条书签ctrl-F2 列出当前工程所有书签 选取// 大部分和导航一致，只不过加上 shiftctrl-shift-P 选取至上一行ctrl-shift-N 选取至下一样ctrl-shift-B 选取至前一个字符ctrl-shift-F 选取至后一个字符alt-shift-B, alt-shift-left 选取至字符开始alt-shift-F, alt-shift-right 选取至字符结束ctrl-shift-E, cmd-shift-right 选取至本行结束ctrl-shift-A, cmd-shift-left 选取至本行开始cmd-shift-up 选取至文件开始cmd-shift-down 选取至文件结尾cmd-A 全选cmd-L 选取一行，继续按回选取下一行ctrl-shift-W 选取当前单词 编辑和删除文本基本操作ctrl-T 使光标前后字符交换cmd-J 将下一行与当前行合并ctrl-cmd-up, ctrl-cmd-down 使当前行向上或者向下移动cmd-shift-D 复制当前行到下一行cmd-K, cmd-U 使当前字符大写cmd-K, cmd-L 使当前字符小写 删除和剪切ctrl-shift-K 删除当前行cmd-backspace 删除到当前行开始cmd-fn-backspace 删除到当前行结束ctrl-K 剪切到当前行结束alt-backspace 或 alt-H 删除到当前单词开始alt-delete 或 alt-D 删除到当前单词结束 多光标和多处选取cmd-click 增加新光标cmd-shift-L 将多行选取改为多行光标ctrl-shift-up, ctrl-shift-down 增加上（下）一行光标cmd-D 选取文档中和当前单词相同的下一处ctrl-cmd-G 选取文档中所有和当前光标单词相同的位置 括号跳转ctrl-m 相应括号之间，html tag 之间等跳转ctrl-cmd-m 括号（tag）之间文本选取alt-cmd-. 关闭当前 XML/HTML tag 编码方式ctrl-shift-U 调出切换编码选项 查找和替换cmd-F 在 buffer 中查找cmd-shift-f 在整个工程中查找 代码片段alt-shift-S 查看当前可用代码片段 在 ~/.atom 目录下 snippets.cson 文件中存放了你定制的snippets 定制说明 自动补全ctrl-space 提示补全信息 折叠alt-cmd-[ 折叠alt-cmd-] 展开alt-cmd-shift-{ 折叠全部alt-cmd-shift-} 展开全部cmd-k cmd-N 指定折叠层级 N 为层级数 文件语法高亮ctrl-shift-L 选择文本类型 使用Atom进行写作ctrl-shift-M Markdown 预览 git操作cmd-alt-Z checkout HEAD 版本cmd-shift-B 弹出 untracked 和 modified 文件列表alt-g down alt-g up 在修改处跳转alt-G D 弹出 diff 列表alt-G O 在 github 上打开文件alt-G G 在 github 上打开项目地址alt-G B 在 github 上打开文件 blamealt-G H 在 github 上打开文件 historyalt-G I 在 github 上打开 issuesalt-G R 在 github 打开分支比较alt-G C 拷贝当前文件在 gihub 上的网址 一些好用的插件 主题atom-material-uiatom-material-syntax 美化atom-beautifyfile-icons 给文件加上好看的图标atom-minimap 方便美观的缩略滚动图 Gitatomatigit 可视化Git操作 代码提示emmetautoclose-htmlcolor-picker 取色器pigments 颜色显示插件terminal-panel 便捷操作advanced-open-file 快速打开、切换文件]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Atom</tag>
        <tag>shortcut</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIStackView to resize/layout]]></title>
    <url>%2FProgramming%2Fuistackview-layout-iboutlet%2F</url>
    <content type="text"><![CDATA[(only IBOutlet this time) 自适应、适配、布局这几个关键词一直伴随着iOS开发，从以前的单一尺寸屏幕，到现在的多尺寸屏幕，Apple一直致力于让开发人员尽可能少在这些事上耗费过多的精力，所以Apple在2012年推出了Auto Layout特性，2014年又推出了Adaptive Layout、Size Classes，2015年iOS 9中又增加了新的控件：UIStackView。这些无一不是我们开发者做适配的利器。 UIStackView简介UIStackView Class Reference 1 The UIStackView class provides a streamlined interface for laying out a collection of views in either a column or a row. Stack views let you leverage the power of Auto Layout, creating user interfaces that can dynamically adapt to the device’s orientation, screen size, and any changes in the available space. The stack view manages the layout of all the views in its arrangedSubviews property. These views are arranged along the stack view’s axis, based on their order in the arrangedSubviews array. The exact layout varies depending on the stack view’s axis, distribution, alignment, spacing, and other properties. UIStackView 提供了一个高效的接口用于平铺一行或一列的视图组合。对于嵌入到 StackView 的视图，你不用再添加自动布局的约束了。Stack View 管理这些子视图的布局，并帮你自动布局约束。 StackView 其实一个视图容器，不过它会对它的子视图根据一定规则自动布局，将子视图按栈的排列方式进行布局。 UIStackView主要的属性一般情况下，我们不需要对 stackView.subviews 做任何约束，只需要通过对 stackView 的 axis, distribution, alignment, spacing 属性进行修改 2 Axis 方向StackView 有水平和垂直两个方向的布局模式 Spacing 间隔StackView 可以设置子视图之间的间隔 Alignment 对齐方式StackView 可以设置子视图的对齐方式（水平方向和垂直方向的该属性值有所区别）： Fill：子视图填充 StackView。 Leading：靠左对齐。 Trailing：靠右对齐。 Center：子视图以中线为基准对齐。 Top：靠顶部对齐。 Bottom：靠底部对齐。 First Baseline：按照第一个子视图中文字的第一行对齐，同时保证高度最大的子视图底部对齐（只在 axis 为水平方向有效）。 Last Baseline：按照最后一个子视图中文字的最后一行对齐，同时保证高度最大的子视图顶部对齐（只在 axis 为水平方向有效）。 Distribution 分布方式StackView 可以设置子视图的分布方式： Fill：默认分布方式。 Fill Equally：子视图的高度或宽度保持一致。 Fill：Proportionally：按比例分布。 Equal Spacing：子视图保持同等间隔。 Equal Centering：每个子视图中心线之间保持一致。 baselineRelativeArrangementdetermines whether the vertical spacing between views is measured from the baselines.决定了其视图间的垂直间隙是否根据基线测量得到，选中 Baseline Relative 将根据 subview 的基线调整垂直间距。3 layoutMarginsRelativeArrangementdetermines whether the stack view lays out its arranged views relative to its layout margins.决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距，选中 Layout Margins Relative 将相对于标准边界空白来调整 subview 位置。 UIStackView的嵌套 Typically, you use a single stack view to lay out a small number of items. You can build more complex view hierarchies by nesting stack views inside other stack views. 既然 UIStackView 继承了 UIView，那么 UIStackView 也可以看做是一个 UIView 而被包含在 UIStackView 内，亦及嵌套使用。 UIStackView 与 UICollectionView 的选取UIStackView 实现有对齐要求的视图布局非常非常得简单，而使用 UICollectionView 和 UITableView 来实现，相对而言就比较麻烦。相比于 collectionView 而言，stackView 更加小巧灵活，然而想要完成更精致的效果，最终还是得使用 UICollectionView。 注意！ Be careful to avoid introducing conflicts when adding constraints to views inside a stack view. As a general rule of thumb, if a view’s size defaults back to its intrinsic content size for a given dimension, you can safely add a constraint for that dimension. 1231. Fill 的方向垂直于Axis2. 有时可能排版较乱，除了设置属性来布局之外，我们还可以手动添加属性，且"手动添加的享有更高的优先级"。(Apple 官方建议开发人员应优先采用 StackView 来设计用户界面，然后再根据实际需求来添加约束) 后记 The UIStackView is a nonrendering subclass of UIView; that is, it does not provide any user interface of its own. Instead, it just manages the position and size of its arranged views. As a result, some properties (like backgroundColor) have no effect on the stack view. Similarly, you cannot override layerClass, drawRect:, or drawLayer:inContext:. UIStackView 不是万能的，但它可以在布局和自适应方面给开发者带来便利，在恰当的情形下使用 StackView 可以事半功倍。而且因为 UIStackView 是 UIView 的子类，所以也可以将动画效果作用于 UIStackView 上，在方便布局之余还能提高用户体验。 隔桌安卓小伙伴不满了，这不就是LinearLayout吗？额 -_-! ThanksTo: [1] UIStackView Class Reference –https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIStackView_Class_Reference/index.html#//apple_ref/occ/instp/UIStackView/distribution[2] UIStackView 小窥 –http://www.devtalking.com/articles/uistackview/?utm_source=tuicool&amp;utm_medium=referral[3] 简便的自动布局，对 UIStackView 的个人理解！ –http://www.cnblogs.com/bokeyuanlibin/p/5693575.html 使用 UIStackView 可以很方便快捷的设置以下布局： // 纯代码的下次再做]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[色彩模型之HSL(HSB)]]></title>
    <url>%2FOthers%2Fcolor-model-hsl-hsb%2F</url>
    <content type="text"><![CDATA[色彩的三要素 —— 色相、明度、纯度 色相（表，表现）：即色彩的相貌和特征。自然界中色彩的种类很多，色相指色彩的种类和名称。如：红、橙、黄、绿、青、蓝、紫等等颜色的种类变化就叫色相。 明度（表，面子）：指色彩的亮度或明度，也叫明亮度。颜色有深浅、明暗的变化。比如，深黄、中黄、淡黄、柠檬黄等黄颜色在明度上就不一样，紫红、深红、玫瑰红、大红、朱红、桔红等红颜色在亮度上也不尽相同。这些颜色在明暗、深浅上的不同变化，也就是色彩的又一重要特征一一明度变化。色彩的明度变化有许多种情况，一是不同色相之间的明度变化。如：白比黄亮、黄比橙亮、橙比红亮、红比紫亮、紫比黑亮；二是在某种颜色中加白色，亮度就会逐渐提高，加黑色亮度就会变暗，但同时它们的纯度(颜色的饱和度)就会降低，三是相同的颜色，因光线照射的强弱不同也会产生不同的明暗变化。 纯度（里，里子）：指色彩的鲜艳程度，也叫饱和度。原色是纯度最高的色彩。颜色混合的次数越多，纯度越低，反之，纯度则高。原色中混入补色，纯度会立即降低、变灰。物体本身的色彩，也有纯度高低之分，西红柿与苹果相比，西红柿的纯度高些，苹果的纯度低些。有好的表现，必然有一定的面子跟里子做基础。 关于水的色彩观念 —— 水，首先是无色的；其次是白色的（可以降低纯度，提高明度；最后是任意色的（经光照反色多彩或折射七彩）。 之前看到过的: 色生心中：人性化的HSL模型 HSL色彩模型又是什么？ HSL同样使用了3个分量来描述色彩，与RGB使用的三色光不同，HSL色彩的表述方式是：H(hue)色相，S(saturation)饱和度，以及L(lightness)亮度。 听起来一样复杂？稍后你就会发现，与“反人类”的RGB模型相比，HSL是多么的友好。 HSL的H(hue)分量，代表的是人眼所能感知的颜色范围，这些颜色分布在一个平面的色相环上，取值范围是0°到360°的圆心角，每个角度可以代表一种颜色。色相值的意义在于，我们可以在不改变光感的情况下，通过旋转色相环来改变颜色。在实际应用中，我们需要记住色相环上的六大主色，用作基本参照：360°/0°红、60°黄、120°绿、180°青、240°蓝、300°洋红，它们在色相环上按照60°圆心角的间隔排列。 HSL的S(saturation)分量，指的是色彩的饱和度，它用0%至100%的值描述了相同色相、明度下色彩纯度的变化。数值越大，颜色中的灰色越少，颜色越鲜艳，呈现一种从理性(灰度)到感性(纯色)的变化。 HSL的L(lightness)分量，指的是色彩的明度，作用是控制色彩的明暗变化。它同样使用了0%至100%的取值范围。数值越小，色彩越暗，越接近于黑色；数值越大，色彩越亮，越接近于白色。 采用HSL颜色体系后, 更能便捷地选取自己偏好或当前合适的颜色.特别对于随机色的表示, 采用RGB可能不太友好(有时偏暗, 外观不佳), 可试试HSL. 如下所示(仅示范, 细心调试后更佳): 1234CGFloat hue = ( arc4random() % 256 / 256.0 ); // 0.0 to 1.0CGFloat saturation = ( arc4random() % 128 / 256.0 ) + 0.5; // 0.5 to 1.0, away from whiteCGFloat brightness = ( arc4random() % 128 / 256.0 ) + 0.5; // 0.5 to 1.0, away from blackUIColor *color = [UIColor colorWithHue:hue saturation:saturation brightness:brightness alpha:1.0];]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>color</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（Design Pattern）]]></title>
    <url>%2FProgramming%2Fdesign-pattern%2F</url>
    <content type="text"><![CDATA[设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。 创建型 (Creational)主要用于描述如何创建对象 单例模式 (Singleton Pattern) 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法. (为了防止在外部对其实例化，将其构造函数设计为私有。) 主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。 适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点 简单工厂模式 (Simple Factory Pattern) 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态 (static) 方法，因此简单工厂模式又被称为静态工厂方法 (Static Factory Method) 模式。它属于类创建型模式。 工厂方法模式 (Factory Method Pattern) 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式 (Virtual Constructor Pattern) 或多态工厂模式 (Polymorphic Factory Pattern)。它属于类创建型模式。 包含四个角色：抽象产品、具体产品、抽象工厂和具体工厂 主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。 适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。 抽象工厂模式 (Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为 Kit 模式，属于对象创建型模式。 四个角色: 抽象工厂、具体工厂、抽象产品和具体产品 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。 主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。 适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 原型模式 (Prototype Pattern) 使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。 三个角色: 抽象原型类、具体原型类和客户类 主要优点是简化复杂对象的创建过程，扩展性较好，还可以使用深克隆的方式保存对象状态，在需要的时候使用可辅助实现撤销操作。主要缺点是需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”；在实现深克隆时需要编写较为复杂的代码。 适用情况包括：创建新对象成本较大，新的对象可以通过原型模式对已有对象进行复制来获得；如果系统要保存对象的状态；需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态。 建造者模式 (Builder Pattern) 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。 四个角色: 抽象建造者、具体建造者、产品角色和指挥者指挥者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。 主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。 结构型 (Structural)主要用于描述如何实现类或对象的组合。 适配器模式 (Adapter Pattern) 桥接模式 (Bridge Pattern) 组合模式 (Composite Pattern) 装饰模式 (Decorator Pattern) 外观模式 (Facade Pattern) 享元模式 (Flyweight Pattern) 代理模式 (Proxy Pattern) 行为型 (Behavioral)主要用于描述类或对象怎样交互以及怎样分配职责。 职责链模式 (Chain of Responsibility Pattern) 命令模式 (Command Pattern) 解释器模式 (Interpreter Pattern) 迭代器模式 (Iterator Pattern) 中介者模式 (Mediator Pattern) 备忘录模式 (Memento Pattern) 观察者模式 (Observer Pattern) 状态模式 (State Pattern) 策略模式 (Strategy Pattern) 模板方法模式 (Template Pattern) 访问者模式 (Visitor Pattern) 设计原则 单一职责原则 (Single Responsibility Principle, SRP) 开闭原则 (Open-Closed Principle) 里氏代换原则 (Liskov Substitution) 依赖倒换原则 (Dependence Inversion Principle, DIP) 接口隔离原则 (Interface Segregation Principle, ISP) 合成复用原则 (Composite Reuse Principle, CRP) 迪米特法则 (Law of Demeter, LoD)]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>none</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类簇 (class cluster)]]></title>
    <url>%2FProgramming%2Fclass-cluster%2F</url>
    <content type="text"><![CDATA[类簇是一种常用的设计模式(基于抽象工厂设计模式)，将一些相近的私有具体的子类组合在一个实体的抽象类下面. 在 Cocoa 中，许多类实际上是以类簇的方式实现的，即它们是一群隐藏在通用接口之下的与实现相关的类. 比如 NSNumber… 对于类簇使用isMemberOfClass和isKindOfClass是不允许的,因为类簇是由抽象公共类管理的一组私有类，抽象公共类并不是真正的实例的父类，类簇中真正的类从属关系被隐藏了，所以使用 isMemberOfClass 和 isKindOfClass 结果可能不准确。 ….]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>none</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numbers]]></title>
    <url>%2FTool%2Fmac-numbers-and-microsoft-excel%2F</url>
    <content type="text"><![CDATA[最近需要用到 Numbers 简单处理/展示一些小东西, 上手过程中几经波折. 怕以后忘记, 简单整理了下. 功能定位直观感受上: Numbers 像是电子表格软件, 用表格/图表/文字共同来组织内容和排版, 在展现数据的同时呈现给我们一个优美的结果, 表格只是其中的主要组件. Excel 则是基于表格的数据分析软件, 到处皆’单元’的风格突出了其对数据的重视, 在数据分析手段和各种专业函数上被 Numbers 详细很多, 还有很多 Numbers 不具备的功能, 例如 OLE 对象/宏/外部数据/数据透视表等等. 日常生活中, Numbers 就够用了. 内置的模板比较实用.Numbers 的定位: 制作以数据展现为目的的报表和报告, 基于页面承载数据来进行数据分析, 作为清单和计划安排类的文稿来使用. 一些使用上的细节基本单元 Excel – “格子里的世界”, 到处都是单元格. Numbers – “能移动的表格”, 表格作为一个对象放置在空白页面(风格上有点儿像 Microsoft OneNote), 一个表单中可以有多个表格对象, 除了表格还可方便的插入图片/文本框/图表, 整个制作过程感觉像排版, 当移动或缩放对象时有智能辅助线作参考. 每个Numbers文件可包含多个表单, 每个表单相当于一页, 每页中可含多个表格和其他对象(图表/文本框/图像/媒体), 每个表格都有各自不同且唯一的名称.单元格上的黄色控制点(上下或左右, 而非右下角)只能在正文或标题行列中进行横向或纵向复制, 不能跨越标题和正文列, 也不能同时复制行和列. Numbers面对对象的格式化概念和 Excel 中面对选择区域格式化的概念是完全不同的, 也是从 Excel 转到 Numbers 时需要特别区分的地方. 边框设置边框设置过程中, 无法修改表格默认格线样式(粗细/颜色/样式), 更像是覆盖性的展现; 且设置边框时, 若对结果不满意, 需要先点击”还原”回到最初状态后, 再重新设置.123456发现个展示小 bug:在表头中想用&quot;\&quot;分隔行列标题栏, 由于没有系统设置格式可供选择, 采用`Shape(形状)`中画线功能, 然后添加两个文本框, 调整各自位置和样式.当滑动表单内容时, 如果采用默认的&quot;冻结标题行&quot;样式, 当标题行冻结时, 反向斜线和文本框随背景画布一块儿被滑出了屏幕.另外, 当移动表单中上述表格, 表格位置改变后, 反向斜线和文本框仍保持在原有位置.从原理上来讲, 斜线和文本框是跟表格&apos;并列&apos;的单独的对象(并列?), 而非表格的子对象, 这样方便呈现不同表格或其它媒体对象元素, 因而出现上述情况. 那么当我们需要添加相对于某表格的对象元素时, 如何保持与该表格相对关系, 也就是随着表格而相应改变?不知是否有更好的处理方式, 还需多多学习 QAQ! 公式样式单元格中公式计算风格样式, Excel 原始展现输入字符; Numbers 将函数名/函数参数/括号等各区块设置不同的颜色和样式, 且单元格引用时会显示所对应行或列的标题栏名称. 例如: 如果是在同页的另一个表中引用C列的第4行显示会是表格1::$C$4, 如果是在其他表单中的公式调用会是工作表1::表格1::$C$4, 采用双冒号来依次分隔表单名称/表格名称/单元格, 内容范围上采用单个冒号来表示. 1个人觉得不太方便的是, 当修改单元格内容时(含公式的单元格需要双击进入编辑模式, 也可用`option+return`快捷键), 只能在对应单元格处理, 而无法在底部的显示行修改(Excel 则可以在顶部的编辑行中修改). 可以将 Numbers 整个表单内容直接复制粘贴到 Pages 中, 内容和公式都会被完整的保留下来, 样式有时稍有调整. 这种将表格作为对象来使用的特性，使得 iWork 套件相互间更加兼容. 且能方便保存到 iCloud, 在各设备上浏览/编辑. 内容的条件高亮显示关于计算公式, 很多时候会使用逻辑函数IF来处理例外和异常, 然而加入了逻辑判断后，会使公式变得很长而且也容易出错.针对内容的条件高亮显示很多时候可以起到同样的判断作用, 且设置更简单, 通过添加规则用颜色/填充/加粗等醒目的方式进行区分.条件高亮规则分数字/文本/日期/持续时间/空白等几个类别, 每一类规则中都包含了固定的一些判断条件, 不能自行设置包含运算和函数的判断.通过添加规则我们可以直观地对一些单独数据进行醒目展示, 以作为数据分拣时的辅助手段来使用. 打印分页在 Numbers 的使用逻辑中, 每个表单可以理解成一个没有大小限制的承载表格和图表等对象的页, 只有在打印输出时才会和实际的纸张大小进行大小的适配, 在表单中排布元素和对象时可以基于所见即所得的方式来排版和设置字体的大小, 如果是计划输出打印的表单页可以添加标尺来划定内容排布的范围. 协作功能Numbers “协作”功能, 由于没有多人合作编辑同一个 Numbers 文件, 不清楚具体细则. 不知是否跟 GIT 类似. prefers:Numbers 函数列表Numbers 公式与函数帮助 reference to:Numbers 使用技巧Numbers使用numbers怎么制作下图这样的单元格内的斜线呢?]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Numbers</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Everything about Ashara Dayne]]></title>
    <url>%2FReading%2Feverything-about-ashara-dayne%2F</url>
    <content type="text"><![CDATA[A Game of ThronesCatelyn That cut deep. Ned would not speak of the mother, not so much as a word, but a castle has no secrets, and Catelyn heard her maids repeating tales they heard from the lips of her husband’s soldiers. They whispered of Ser Arthur Dayne, the Sword of the Morning, deadliest of the seven knights of Aerys’s Kingsguard, and of how their young lord had slain him in single combat. And they told how afterward Ned had carried Ser Arthur’s sword back to the beautiful young sister who awaited him in a castle called Starfall on the shores of the Summer Sea. The Lady Ashara Dayne, tall and fair, with haunting violet eyes. It had taken her a fortnight to marshal her courage, but finally, in bed one night, Catelyn had asked her husband the truth of it, asked him to his face.That was the only time in all their years that Ned had ever frightened her. “Never ask me about Jon,” he said, cold as ice. “He is my blood, and that is all you need to know. And now I will learn where you heard that name, my lady.” She had pledged to obey; she told him; and from that day on, the whispering had stopped, and Ashara Dayne’s name was never heard in Winterfell again. 这件事伤她很深，奈德非但不肯说出孩子的母亲，连关系情形半个字也不跟她提。然而城堡里没有不透风的墙，凯特琳很快就从她的侍女群中听说了几种揣测，这些都是从跟随她丈夫打仗的士兵嘴里传出来的。她们交头接耳说着外号“拂晓神剑”的亚瑟·戴恩爵士，说他是伊里斯麾下御林七铁卫中武艺最高强的骑士，但他们的年轻主子却在一对一的决斗中击毙了他。她们还绘声绘影地叙述事后奈德是如何地带着亚瑟爵士的佩剑，前往盛夏海岸的星坠城寻找亚瑟的妹妹。她们说亚夏拉·戴恩小姐皮肤白皙，身材高挑，一双紫罗兰色的眸子深邃而幽冷。她想了两个星期才终于鼓起勇气，某天夜里在床上向丈夫当面问起。然而，那却是两人结婚多年以来，奈德惟一吓着她的一次。“永远不要跟我问起琼恩的事，”他的口气寒冷如冰，“他是我的亲生骨肉，你只需知道这点就够了。现在，夫人，我要知道你是打哪儿听来这名字的。”她向他保证以后不会再提起这件事，于是便把消息来源告诉了他。翌日起，城中一切谣言戛然而止，临冬城中从此再听不到亚夏拉·戴恩这个名字。 Eddard Be kind to me, Ned. I swear to you, you shall never regret it.”“Did you make the same offer to Jon Arryn?”She slapped him.“I shall wear that as a badge of honor,” Ned said dryly.“Honor,” she spat. “How dare you play the noble lord with me! What do you take me for? You’ve a bastard of your own, I’ve seen him. Who was the mother, I wonder? Some Dornish peasant you raped while her holdfast burned? A whore? Or was it the grieving sister, the Lady Ashara? She threw herself into the sea, I’m told. Why was that? For the brother you slew, or the child you stole? Tell me, my honorable Lord Eddard, how are you any different from Robert, or me, or Jaime?” “奈德，对我好一点，我发誓绝不让你后悔。”“你当初也是这么向琼恩·艾林提议吗？”她甩了他一个耳光。“我会把这当成荣誉的奖章。”奈德冷冷地说。“去你的荣誉，”她啐道，“少给我道貌岸然！你把我当什么了？你自己也有个私生子，我亲眼见过。我很好奇他的母亲是谁？是不是哪个家园被你放火烧掉，随后被你强奸的多恩农家女？还是个婊子？或者是那个哀伤的妹妹，亚夏拉小姐？我听说，当你将拂晓神剑那把‘黎明’送还给她后，她便从城墙投海自尽，这到底是什么缘故啊？是因为被你所杀的哥哥，还是被你偷走的孩子？告诉我啊，最讲究荣誉的艾德大人，你和劳勃，或是我，或是詹姆，究竟有什么差别？” A Clash of KingsCatelyn Her own children had more Tully about them than Stark. Arya was the only one to show much of Ned in her features. And Jon Snow, but he was never mine. She found herself thinking of Jon’s mother, that shadowy secret love her husband would never speak of. Does she grieve for Ned as I do? Or did she hate him for leaving her bed for mine? Does she pray for her son as I have prayed for mine?They were uncomfortable thoughts, and futile. If Jon had been born of Ashara Dayne of Starfall, as some whispered, the lady was long dead; if not, Catelyn had no clue who or where his mother might be. And it made no matter. Ned was gone now, and his loves and his secrets had all died with him. 就她自己的孩子而论，徒利方面的特征就比史塔克方面的来得明显。长得和奈德相仿的只有艾莉亚，以及琼恩·雪诺，但他不是我的孩子。她不禁又想起琼恩的母亲，想起奈德谜一般的影子爱侣，想起丈夫一直不肯提起的“她”。她也为奈德哀悼么?她恨他选择了我而抛弃了她吗?她也同我一样在为孩子祈祷吗?这些念头让她不安，她知道它们毫无意义。如果谣言属实，琼恩真是星坠城的亚夏拉·戴恩所生，那他母亲已经丧命很久；如果不是，凯特琳对他母亲的所在和身世就没了一点线索。不过这些都无关紧要。奈德去了，他的爱、他的秘密都和他一同消逝。 A Storm of SwordsArya “My father was called Ned too,” she said.“I know. I saw him at the Hand’s tourney. I wanted to go up and speak with him, but I couldn’t think what to say.” Ned shivered beneath his cloak, a sodden length of pale purple. “Were you at the tourney? I saw your sister there. Ser Loras Tyrell gave her a rose.”“She told me.” It all seemed so long ago. “Her friend Jeyne Poole fell in love with your Lord Beric.”“He’s promised to my aunt.” Ned looked uncomfortable. “That was before, though. Before he . . .”. . . died? she thought, as Ned’s voice trailed off into an awkward silence. Their horses’ hooves made sucking sounds as they pulled free of the mud.“My lady?” Ned said at last. “You have a baseborn brother . . . Jon Snow?”“He’s with the Night’s Watch on the Wall.” Maybe I should go to the Wall instead of Riverrun.Jon wouldn’t care who I killed or whether I brushed my hair . . . “Jon looks like me, even thoughhe’s bastard-born. He used to muss my hair and call me ‘little sister.’” Arya missed Jon most of all.Just saying his name made her sad. “How do you know about Jon?”“He is my milk brother.”“Brother?” Arya did not understand. “But you’re from Dorne. How could you and Jon beblood?”“Milk brothers. Not blood. My lady mother had no milk when I was little, so Wylla had to nurseme.”Arya was lost. “Who’s Wylla?”“Jon Snow’s mother. He never told you? She’s served us for years and years. Since before I wasborn.”“Jon never knew his mother. Not even her name.” Arya gave Ned a wary look. “You know her?Truly?” Is he making mock of me? “If you lie I’ll punch your face.”“Wylla was my wetnurse,” he repeated solemnly. “I swear it on the honor of my House.”“You have a House?” That was stupid; he was a squire, of course he had a House. “Who are you?”“My lady?” Ned looked embarrassed. “I’m Edric Dayne, the . . . the Lord of Starfall.”Behind them, Gendry groaned. “Lords and ladies,” he proclaimed in a disgusted tone. Arya plucked a withered crabapple off a passing branch and whipped it at him, bouncing it off his thickbull head. “Ow,” he said. “That hurt.” He felt the skin above his eye. “What kind of lady throws crabapples at people?”“The bad kind,” said Arya, suddenly contrite. She turned back to Ned. “I’m sorry I didn’t know who you were. My lord.”“The fault is mine, my lady.” He was very polite. “我父亲也叫艾德，”她说。“我知道。我在首相的比武大会上见过他，本想上前跟他说话呢，却想不出说什么。”艾德在斗篷下颤抖，淡紫色长斗篷浸满了水。“您也在比武大会上吗?我看到您姐姐在那儿，洛拉斯·提利尔爵士送她一朵玫瑰。”“她告诉我了。”一千年前的往事。“她的朋友珍妮·普尔爱上了你们的贝里伯爵。”“他跟我姑母订婚了。”艾德有些不安。“但那是从前。在他……”……死之前?她心想，艾德的声音逐渐减弱，变成窘迫的沉默。马蹄在泥泞中踩踏，发出粘乎乎的声音。“小姐?”艾德最后道，“您有个庶出的哥哥……琼恩·雪诺?”“他在长城的守夜人军团服役。”也许我该去长城，而不是奔流城。琼恩不会在乎我杀了谁，或者我梳不梳头发……“琼恩的模样跟我很像，尽管他是私生子。他以前常弄乱我的头发，叫我‘我的小妹’。”艾莉亚最想念琼恩，单单说出他的名字就让她伤心。“你怎么知道琼恩?”“他是我的乳奶兄弟。”“兄弟?”艾莉亚不明白，“但你来自多恩，怎会跟琼恩是亲戚?”“是乳奶兄弟，无血缘关系的。我小时候，母亲大人没有奶水，不得不让薇拉喂奶。”艾莉亚完全糊涂了。“谁是薇拉?”“琼恩·雪诺的母亲，他没告诉您吗?她为我们效力有好多好多年，从我出生以前就开始。” “琼恩从不知道他母亲是谁，甚至连她的名字都不知道。”艾莉亚警惕地看了艾德一眼，“你认识她?真的?”他在开我玩笑?“如果你撒谎，我就揍你的脸。”“薇拉是我的乳母，”他严肃地重复，“我以我家族的荣誉起誓。”“你的家族?”真笨!他是个侍从，当然有家族。“你到底是谁啊?”“小姐?”艾德似乎很窘迫。“我是艾德瑞克·戴恩……星坠城领主。”詹德利在身后发出呻吟。“领主与小姐，”他用厌恶的语气叫道。艾莉亚顺手从树枝上摘下一颗干瘪的酸果朝他丢去，砸在那颗笨钝的牛脑袋上。“噢，”他说，“好疼。”他摸摸眼睛上方，“哪门子小姐会朝百姓扔东西啊?”“坏的那种，”艾莉亚说，突然感到几分懊悔，连忙转回头面对艾德。“抱歉，我不知您的身份，大人。”“是我的错，小姐。”他非常礼貌。 Jon has a mother. Wylla, her name is Wylla. She would need to remember so she could tell him, the next time she saw him. She wondered if he would still call her “little sister.” I’m not so little anymore. He’d have to call me something else. Maybe once she got to Riverrun she could write Jon a letter and tell him what Ned Dayne had said. “There was an Arthur Dayne,” she remembered. “The one they called the Sword of the Morning.”“My father was Ser Arthur’s elder brother. Lady Ashara was my aunt. I never knew her, though. She threw herself into the sea from atop the Palestone Sword before I was born.”“Why would she do that?” said Arya, startled.Ned looked wary. Maybe he was afraid that she was going to throw something at him. “Your lord father never spoke of her?” he said. “The Lady Ashara Dayne, of Starfall?”“No. Did he know her?”“Before Robert was king. She met your father and his brothers at Harrenhal, during the year of the false spring.”“Oh.” Arya did not know what else to say. “Why did she jump in the sea, though?”“Her heart was broken.”Sansa would have sighed and shed a tear for true love, but Arya just thought it was stupid. She couldn’t say that to Ned, though, not about his own aunt. “Did someone break it?”He hesitated. “Perhaps it’s not my place . . .”“Tell me.”He looked at her uncomfortably. “My aunt Allyria says Lady Ashara and your father fell in love at Harrenhal—”“That’s not so. He loved my lady mother.”“I’m sure he did, my lady, but—”“She was the only one he loved.”“He must have found that bastard under a cabbage leaf, then,” Gendry said behind them. 琼恩有个母亲。薇拉，她叫薇拉。她得记住，下次见面就可以告诉他。她不知琼恩是否还会叫自己“我的小妹”。我已经不小了。他得换个称呼。或许等到了奔流城，就给琼恩写封信，把艾德·戴恩说的告诉他。“有个亚瑟·戴恩，”她记起来，“是什么‘拂晓神剑’。”“我父亲是亚瑟爵士的哥哥，还有个妹妹亚夏拉小姐——但我从来不认识她，她在我出生之前，就从白石剑塔顶跳进了大海。”“她为何这么做呀?”艾莉亚惊讶万分地问。艾德看上去很小心，似乎害怕艾莉亚也朝自己扔东西。“您父亲大人没告诉过您吗?”他问，“星坠城的亚夏拉·戴恩小姐?”“没有。他认识她?”“劳勃成为国王之前，她在赫伦堡与您父亲和他的兄弟姐妹们相遇，那一年是错误的春天。”“哦，”艾莉亚不知该说什么，“她为什么要跳进海里呢?”“因为她的心碎了。”珊莎会为真爱而叹息流泪，但艾莉亚觉得那很笨。当然，她不能这么对艾德讲，不能这么说他的亲姑母。“是有人让她心碎吗?”他犹豫不决，“也许我不该……”“告诉我嘛。”他惴惴地看着她，“据我姑母阿莉里亚说，亚夏拉和您父亲在赫伦堡相爱——”“不会的。他爱我母亲大人。”“我肯定他很爱，可是，小姐——”“他只爱她一个。”“那他一定是在白菜叶子底下找到的私生子。”詹德利在后面说。 It was Harwin who rode up beside her, in the end. “Where do you think you’re going, milady? You shouldn’t run off. There are wolves in these woods, and worse things.”“I’m not afraid,” she said. “That boy Ned said . . .”“Aye, he told me. Lady Ashara Dayne. It’s an old tale, that one. I heard it once at Winterfell, when I was no older than you are now.” He took hold of her bridle firmly and turned her horse around. “I doubt there’s any truth to it. But if there is, what of it? When Ned met this Dornish lady, his brother Brandon was still alive, and it was him betrothed to Lady Catelyn, so there’s no stain on your father’s honor. There’s nought like a tourney to make the blood run hot, so maybe some words were whispered in a tent of a night, who can say? Words or kisses, maybe more, but where’s the harm in that? Spring had come, or so they thought, and neither one of them was pledged.”“She killed herself, though,” said Arya uncertainly. “Ned says she jumped from a tower into the sea.”“So she did,” Harwin admitted, as he led her back, “but that was for grief, I’d wager. She’d lost a brother, the Sword of the Morning.” He shook his head. “Let it lie, my lady. They’re dead, all of them. Let it lie . . . and please, when we come to Riverrun, say naught of this to your mother.” 最后是哈尔温骑到她边上。“你想上哪儿去，小姐?你不该独自跑开，森林里有狼群，还有更糟糕的东西。”“我才不怕，”她说。“那个叫艾德的男孩说……”“对，他也告诉了我。亚夏拉·戴恩小姐。这是个老故事，我在临冬城就听过一次，那时跟你差不多大呢。”他牢牢抓住她坐骑的缰绳，圈转过来。“我怀疑其中毫无真相可言。即使有，又怎样呢?你父亲艾德大人与这位多恩的小姐相遇时，他哥哥布兰登仍在世，并跟凯特琳女士订了婚，所以他的荣誉并未遭到玷污。比武大会是最令人热血沸腾的场合，也许某天晚上，某个帐篷，某次幽会，谁说得准呢?幽会，亲吻，也许不止于此，那又有什么害处呢?春天来了，至少当时他们那么想，而且彼此都没有婚约。”“但她自杀了，”艾莉亚不大确定地说，“艾德说她从一座塔上跳进了海里。”“她是自杀了，”哈尔温边领她回去，边承认，“我敢打赌，那是因为悲伤，别忘记，她失去了哥哥，传奇的拂晓神剑。”他摇摇头。“随它去吧，小姐，他们都死了，所有人都死了，随它去吧……还有，到达奔流城后，千万不要把这些事告诉你母亲。” Bran The storm lord drank down the knight of skulls and kisses in a wine-cup war. The crannogman saw a maid with laughing purple eyes dance with a white sword, a red snake, and the lord of griffins, and lastly with the quiet wolf . . . but only after the wild wolf spoke to her on behalf of a brother too shy to leave his bench.(……) The quiet wolf had offered the little crannogman a place in his tent that night, (…..) 风暴领主斗酒击败了头骨与亲吻骑士。泽地人看到一位少女，她有一双会微笑的、紫罗兰色的眼眸，她跟白袍剑客跳舞，跟红色毒蛇跳舞，跟狮鹫大人跳舞，最后跟那沉默的狼……不过是在野狼替弟弟邀请之后，他弟弟太害羞，不曾离开座位。”……那天晚上，沉默的狼邀他同住，…… A Dance with DragonsBarristan Rhaegar had chosen Lyanna Stark of Winterfell. Barristan Selmy would have made a different choice.Not the queen, who was not present. Nor Elia of Dorne, though she was good and gentle; had she been chosen, much war and woe might have been avoided. His choice would have been a young maiden not long at court, one of Elia’s companions … though compared to Ashara Dayne, the Dornish princess was a kitchen drab.Even after all these years, Ser Barristan could still recall Ashara’s smile, the sound of her laughter. He had only to close his eyes to see her, with her long dark hair tumbling about her shoulders and those haunting purple eyes. Daenerys has the same eyes. Sometimes when the queen looked at him, he felt as if he were looking at Ashara’s daughter …But Ashara’s daughter had been stillborn, and his fair lady had thrown herself from a tower soon after, mad with grief for the child she had lost, and perhaps for the man who had dishonored her at Harrenhal as well. She died never knowing that Ser Barristan had loved her. How could she? He was a knight of the Kingsguard, sworn to celibacy. No good could have come from telling her his feelings. No good came from silence either. If I had unhorsed Rhaegar and crowned Ashara queen of love and beauty, might she have looked to me instead of Stark?He would never know. But of all his failures, none haunted Barristan Selmy so much as that. 雷加选择了临冬城的莱安娜·史塔克，巴利斯坦·赛尔弥会做出完全不同的选择。不是王后，她没出席；也非多恩的伊莉亚，尽管她善良温柔，若雷加选她，七国将避免多少战争和灾难，他会选择一位进宫不久的少女，她是伊莉亚的女伴……然而，与亚夏拉·戴恩相比，多恩公主也黯然失色。时隔多年，亚夏拉的音容笑貌仍然历历在目，巴利斯坦爵士只要闭上眼睛就能看见她：长长的黑发披在肩头，紫色的双眸让人流连。丹妮莉丝有同样的眼睛。有时女王看着他，他觉得自己看到了亚夏拉的女儿……但亚夏拉的女儿早就胎死腹中，没多久他美丽的女士也跳下高塔，那是出于失去孩子的伤心欲绝，还是因为在赫伦堡玷污她名誉的男人？她至死不知巴利斯坦爵士的感情。她怎会知道？他是御林铁卫的骑士，发誓终身不娶，对她倾诉爱意毫无益处。但保持沉默也无益处。若我将雷加挑落马下，为亚夏拉戴上爱与美的后冠，或许她就会注意我，而非史塔克？他永远没法知道了。在巴利斯坦·赛尔弥的所有失败中，没有哪次让他这样耿耿于怀。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>A Song of Ice and Fire</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法]]></title>
    <url>%2FTool%2Fmarkdown-syntax%2F</url>
    <content type="text"><![CDATA[概述Markdown 是一种轻量级标记语言，能将文本换成有效的XHTML(或者HTML)文档，它的目标是实现易读易写，成为一种适用于网络的书写语言。 Markdown 语法简洁明了，易于掌握。理念是让文档更容易读、写和改。 HTML 是一种发布的格式，Markdown 是一种书写的格式。 Note: Using Markdown doesn’t mean that you can’t also use HTML. You can add HTML tags to any Markdown file. This is helpful if you prefer certain HTML tags to Markdown syntax. For example, some people find that it’s easier to use HTML tags for images. 区块元素段落 ParagraphsTo create paragraphs, use a blank line to separate one or more lines of text. You should not indent paragraphs with spaces or tabs. 123I really like using Markdown.I think I'll use it to format all of my documents from now on. 123&lt;p&gt;I really like using Markdown.&lt;/p&gt;&lt;p&gt;I think I'll use it to format all of my documents from now on.&lt;/p&gt; 换行 Line BreaksTo create a line break (&lt;br&gt;), end a line with two or more spaces, and then type return. 12This is the first line. And this is the second line. 12&lt;p&gt;This is the first line.&lt;br&gt;And this is the second line.&lt;/p&gt; 如果想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 标题 HeadingsMarkdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式类 Setext 形式是用底线的形式，利用 =（最高阶标题）和 -（第二阶标题），例如： 12345This is an H1=============This is an H2------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 12345# 这是 H1 标题## 这是 H2 标题###### 这是 H6 标题 你可以选择性地“闭合类” atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： 12345# 这是 H1 标题 ### 这是 H2 标题 ##### 这是 H3 标题 ###### 区块引用 BlockquotesMarkdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt;： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt;&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Blockquotes with Multiple ParagraphsMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt;： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用嵌套 Nested Blockquotes区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt;： 12345&gt; This is the first level of quoting.&gt;&gt;&gt; This is nested blockquote.&gt;&gt; Back to the first level. Blockquotes with Other Elements引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 1234&gt; ## 这是一个标题。&gt;&gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表 ListsMarkdown 支持有序列表和无序列表。 无序列表 Unordered Lists无序列表使用*、+或是-作为列表标记： 123* Red* Green* Blue 有序列表 Ordered Lists有序列表则使用数字接着一个英文句点： 1231. Red2. Green3. Blue 列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： 12345&lt;ol&gt;&lt;li&gt;Red&lt;/li&gt;&lt;li&gt;Green&lt;/li&gt;&lt;li&gt;Blue&lt;/li&gt;&lt;/ol&gt; 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 标签包起来，举例来说： 12345* Red* Green* Blue 会被转换为： 12345&lt;ul&gt;&lt;li&gt;&lt;p&gt;Red&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Green&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Blue&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; Adding Elements in ListsParagraphs列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1234567891. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： 1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. Blockquotes如果要在列表项目内放进引用，那 &gt; 就需要缩进： 1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. Code Blocks如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： 123* 一列表项包含一个列表区块： &lt;代码写在这&gt; Notice当然，项目列表很可能会不小心产生，像是下面这样的写法： 11986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 11986\. What a great season. 代码区块 Code Blocks和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 123这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： 1234&lt;p&gt;这是一个普通段落：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;这是一个代码区块。&lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： 12345Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： 123456&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tell application "Foo" beepend tell&lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面，&amp;、&lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： 123&lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation&lt;/div&gt; 会被转换为： 1234&lt;pre&gt;&lt;code&gt;&amp;lt;div class="footer"&amp;gt; &amp;amp;copy; 2004 Foo Corporation&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线 Horizontal Rules可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格： 123456789* * *********- - ---------------------------------------- 区段元素链接 LinksMarkdown 支持两种形式的链接语法：行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 行内式要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 会产生： 12345&lt;p&gt;This is &lt;a href="http://example.com/" title="Title"&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;&lt;p&gt;&lt;a href="http://example.net/"&gt;This link&lt;/a&gt; has notitle attribute.&lt;/p&gt; 如果你是要链接到同样主机的资源，你可以使用相对路径： 1See my [About](/about/) page for details. 参考式 Reference-style Links参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： 1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： 1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 1[id]: http://example.com/ &quot;Optional Title Here&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： 123[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &apos;Optional Title Here&apos;[foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown 部分版本可能会忽略单引号包起来的链接 title。 链接网址也可以用尖括号包起来： 1[id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： 12[id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： 12[link text][a][link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： 1[Google][] 然后定义链接内容： 1[Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： 1Visit [Google Play][] for more information. 然后接着定义链接： 1[Google Play]: https://play.google.com/store 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： 123456I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： 123456I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 1234&lt;p&gt;I get 10 times more traffic from &lt;a href="http://google.com/"title="Google"&gt;Google&lt;/a&gt; than from&lt;a href="http://search.yahoo.com/" title="Yahoo Search"&gt;Yahoo&lt;/a&gt;or &lt;a href="http://search.msn.com/" title="MSN Search"&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： 123I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or[MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调 Emphasis加粗 BoldMarkdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围。 斜体 Italic用 ** 或 __ 包起来的话，则会被转成 &lt;strong&gt;。 加粗并斜体 Bold and ItalicTo emphasize text with bold and italics at the same time, add three asterisks or underscores before and after a word or phrase. 1234567891011*single asterisks*_single underscores_**double asterisks**__double underscores__***double underscores***___double underscores___ 会转成： 1234567&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： 1un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： 1\*this text is surrounded by literal asterisks\* 代码 Code如果要标记一小段行内代码，你可以用反引号（`）把它包起来，例如： 1Use the `printf()` function. 会产生： 1&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： 1``There is a literal backtick (`) here.`` 这段语法会产生： 1&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： 123A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` `` 会产生： 123&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： 1Please don&apos;t use any `&lt;blink&gt;` tags. 转为： 1&lt;p&gt;Please don't use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 你也可以这样写： 1`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 产生： 12&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encodedequivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 图片 ImagesMarkdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式：行内式和参考式。 行内式行内式的图片语法看起来像是： 123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式参考式的图片语法则长得像这样： 1![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 1[id]: url/to/image &quot;Optional title attribute&quot; 到目前为止，Markdown 尚未支持指定图片的宽高，如果需要的话，你可以使用普通的 &lt;img&gt; 标签（或者使用第三方图床）。 Linking ImagesTo add a link to an image, enclose the Markdown for the image in brackets, and then add the link in parentheses. 1[![An old rock in the desert](https://d33wubrfki0l68.cloudfront.net/70a143fdf134aacde3740662a2a47a2a1ee0d216/276c9/assets/images/shiprock.jpg)](https://www.markdownguide.org/basic-syntax#linking-images) The rendered output looks like this: 基本语法的补充自动链接 URLs and Email AddressesMarkdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： 1&lt;http://example.com/&gt; Markdown 会转为： 1&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： 1&lt;address@example.com&gt; Markdown 会转成： 1234&lt;a href="&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;"&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的 “address@example.com”链接。 反斜杠 Backslash (for Escaping Characters)Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠： 1\* Without the backslash, this would be a bullet in an unordered list. Characters You Can EscapeMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 Extended SyntaxExtended syntax isn’t available in all Markdown applications. You’ll need to check whether or not the lightweight markup language your application is using supports extended syntax. If it doesn’t, it may still be possible to enable extensions in your Markdown processor. TablesTo add a table, use three or more hyphens (—) to create each column’s header, and use pipes (|) to separate each column. You can optionally add pipes on either end of the table. 1234| Syntax | Description || ----------- | ----------- || Header | Title || Paragraph | Text | The rendered output: Syntax Description Header Title Paragraph Text Cell widths can vary, as shown below. The rendered output will look the same. 1234| Syntax | Description || --- | ----------- || Header | Title || Paragraph | Text | Tip: Creating tables with hyphens and pipes can be tedious. To speed up the process, try using the Markdown Tables Generator. Build a table using the graphical interface, and then copy the generated Markdown-formatted text into your file. AlignmentYou can align text in the columns to the left, right, or center by adding a colon (:) to the left, right, or on both side of the hyphens within the header row. 1234| Syntax | Description | Test Text || :--- | :----: | ---: || Header | Title | Here&apos;s this || Paragraph | Text | And more | The rendered output: Syntax Description Test Text Header Title Here’s this Paragraph Text And more Formatting Text in TablesYou can format the text within tables. For example, you can add links, code (words or phrases in tick marks (`) only, not code blocks), and emphasis. You can’t add headings, blockquotes, lists, horizontal rules, images, or HTML tags. Escaping Pipe Characters in TablesYou can display a pipe (|) character in a table by using its HTML character code (&amp;#124;). Fenced Code BlocksThe basic Markdown syntax allows you to create code blocks by indenting lines by four spaces or one tab. If you find that inconvenient, try using fenced code blocks. Depending on your Markdown processor or editor, you’ll use three tick marks (` or three tildes (`~~~`) on the lines before and after the code block. The best part? You don’t have to indent any lines!12 { “firstName”: “John”, “lastName”: “Smith”, “age”: 25}1234567891011##### Syntax HighlightingTo add syntax highlighting, specify a language next to the tick marks before the fenced code block.```json&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125; FootnotesFootnotes allow you to add notes and references without cluttering the body of the document. When you create a footnote, a superscript number with a link appears where you added the footnote reference. Readers can click the link to jump to the content of the footnote at the bottom of the page. To create a footnote reference, add a caret and an identifier inside brackets ([^1]). Identifiers can be numbers or words, but they can’t contain spaces or tabs. Identifiers only correlate the footnote reference with the footnote itself — in the output, footnotes are numbered sequentially. Add the footnote using another caret and number inside brackets with a colon and text ([^1]: My footnote.). You don’t have to put footnotes at the end of the document. You can put them anywhere except inside other elements like lists, block quotes, and tables. 1234567891011Here&apos;s a simple footnote,[^1] and here&apos;s a longer one.[^bignote][^1]: This is the first footnote.[^bignote]: Here&apos;s one with multiple paragraphs and code. Indent paragraphs to include them in the footnote. `&#123; my code &#125;` Add as many paragraphs as you like. Heading IDsMany Markdown processors support custom IDs for headings — some Markdown processors automatically add them. Adding custom IDs allows you to link directly to headings and modify them with CSS. To add a custom heading ID, enclose the custom ID in curly braces on the same line as the heading. 1### My Great Heading &#123;#custom-id&#125; The HTML looks like this: 1&lt;h3 id="custom-id"&gt;My Great Heading&lt;/h3&gt; Linking to Heading IDsYou can link to headings with custom IDs in the file by creating a standard link with a number sign (#) followed by the custom heading ID. Markdown HTML Rendered Output IDs](#heading-ids)``` | ```]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空之境界（空の境界，the Garden of sinners）]]></title>
    <url>%2FReading%2Fthe-garden-of-sinners%2F</url>
    <content type="text"><![CDATA[俯瞰风景我对过去的我没有自信。我缺乏身为我的实际感受。我就像一个刚出生的婴儿一无所知，什么也不曾获得。然而，十七年份的记忆将我构成一个完整的人类。原本应该借由种种体验习得的感情早已存在于记忆中，可是我根本没亲身体验过。即使试图体验，结果也早已知晓。其中既没有感动可言，也没有活着的实感。就像已经揭开手法的魔术那样无法令人吃惊。连活着的实感也没有的我，就这么重复着过去的我会有的行动。说不定这样做，就能变回过去的自己。 更新历史 拟定初稿 参考 《空の境界》]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>TYPE-MOON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生若只如初见]]></title>
    <url>%2FReading%2Fif-the-very-first-glance-could-last-forever%2F</url>
    <content type="text"><![CDATA[这个妹妹我曾见过的 一语未了，只听外面一阵脚步响，丫鬟进来笑道：“宝玉来了！”黛玉心中正疑惑着：“这个宝玉，不知是怎个惫懒人物，懵懂顽童？”——倒不见那蠢物也罢了。心中想着，忽见丫鬟话未报完，已进来了一位年轻的公子。黛玉一见，便吃一大惊，心下想到：“好生奇怪，倒像在哪见过一般，何等眼熟到如此！”……天然一段风骚，全在眉梢，平生万种情思，悉堆眼角，看其外貌最是极好，却难知其底细。……两弯似蹙非蹙罥烟眉，一双似泣非泣含露目。态生两靥之愁，娇妻一身之病，泪光点点，娇喘微微，闲静时如姣花照水，行动处似弱柳扶风。心较比干多一窍，病如西子胜三分。宝玉看罢，因笑道：“这个妹妹我曾见过的。”贾母笑道：“可又是胡说，你又何曾见过她？”宝玉笑道：“虽然未曾见过她，然我看着面善，心里就算是旧相识，今日只作远别重逢，亦未为不可。” 这便是宝玉与黛玉的初见，似是初遇，偏又重逢。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
  </entry>
</search>
